<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInLeft","post_block":"fadeInDown","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInLeft"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据结构2024.4.15第9章 查找 动态查找表：在查找的同时对表进行修改操作（增删改） 静态查找表：查找过程不涉及表的操作">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structures Notes">
<meta property="og:url" content="http://example.com/2025/01/01/Data%20Structure_Note/index.html">
<meta property="og:site_name" content="MSZ006&#39;s Cockpit">
<meta property="og:description" content="数据结构2024.4.15第9章 查找 动态查找表：在查找的同时对表进行修改操作（增删改） 静态查找表：查找过程不涉及表的操作">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2025/01/01/Data%20Structure_Note/image/binsearch.png">
<meta property="og:image" content="http://example.com/2025/01/01/Data%20Structure_Note/image/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3.png">
<meta property="article:published_time" content="2025-01-02T01:32:42.000Z">
<meta property="article:modified_time" content="2025-01-02T04:38:13.442Z">
<meta property="article:author" content="Flynn Fu">
<meta property="article:tag" content="computer basis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/01/01/Data%20Structure_Note/image/binsearch.png">


<link rel="canonical" href="http://example.com/2025/01/01/Data%20Structure_Note/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/01/01/Data%20Structure_Note/","path":"2025/01/01/Data Structure_Note/","title":"Data Structures Notes"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Data Structures Notes | MSZ006's Cockpit</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MSZ006's Cockpit</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">MSZ006's Blogs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About me</a></li><li class="menu-item menu-item-projects"><a href="/categories/Projects/" rel="section"><i class="fa fa-code fa-fw"></i>Projects</a></li><li class="menu-item menu-item-blogs"><a href="/categories/Blogs/" rel="section"><i class="fa fa-blog fa-fw"></i>Blogs</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2024-4-15"><span class="nav-number">1.1.</span> <span class="nav-text">2024.4.15</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.</span> <span class="nav-text">第9章 查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.1.</span> <span class="nav-text">树表的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.2.</span> <span class="nav-text">哈希表的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.</span> <span class="nav-text">第10章 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">归并排序(二路归并排序)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.7.</span> <span class="nav-text">简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.8.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.9.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.10.</span> <span class="nav-text">桶排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%9B%BE"><span class="nav-number">1.4.</span> <span class="nav-text">第8章 图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">深度优先遍历（DFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">广度优先遍历（BFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.3.</span> <span class="nav-text">生成树与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Prim算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.4.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">1.4.5.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bellman-ford%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Bellman-ford算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPFA%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">SPFA算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">Floyd算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Astar%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">Astar算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">1.5.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brute-Force%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">Brute-Force算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%93%8D%E4%BD%9C-Union-find"><span class="nav-number">1.6.1.</span> <span class="nav-text">并查集操作(Union find)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.2.</span> <span class="nav-text">三元组操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.6.3.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.6.4.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91-B%E6%A0%91"><span class="nav-number">1.6.5.</span> <span class="nav-text">B+树&#x2F;B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-Black-Tree%EF%BC%89"><span class="nav-number">1.6.6.</span> <span class="nav-text">红黑树（Red-Black Tree）</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Flynn Fu"
      src="/images/avatar_msz006.jpg">
  <p class="site-author-name" itemprop="name">Flynn Fu</p>
  <div class="site-description" itemprop="description">No because they are easy, but because they are hard</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/MSZ-006V" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MSZ-006V" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ymrenfu@gmail.com" title="E-Mail → ymrenfu@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/yinmingren-fu-msz006/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;yinmingren-fu-msz006&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
      <span class="links-of-author-item">
        <a href="/files/Resume.pdf" title="Resume → files&#x2F;Resume.pdf" rel="noopener me"><i class="fa fa-file fa-fw"></i>Resume</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/01/Data%20Structure_Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_msz006.jpg">
      <meta itemprop="name" content="Flynn Fu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MSZ006's Cockpit">
      <meta itemprop="description" content="No because they are easy, but because they are hard">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Data Structures Notes | MSZ006's Cockpit">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Data Structures Notes
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-01-01 17:32:42 / Modified: 20:38:13" itemprop="dateCreated datePublished" datetime="2025-01-01T17:32:42-08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="2024-4-15"><a href="#2024-4-15" class="headerlink" title="2024.4.15"></a>2024.4.15</h2><h2 id="第9章-查找"><a href="#第9章-查找" class="headerlink" title="第9章 查找"></a>第9章 查找</h2><ul>
<li>动态查找表：在查找的同时对表进行修改操作（增删改）</li>
<li>静态查找表：查找过程不涉及表的操作<span id="more"></span></li>
<li>平均查找长度（ASL），分为ASL成功与ASL不成功<br>$$<br>ASL &#x3D; \sum_{i&#x3D;1}^{n} c_i \cdot p_i<br>$$<br>$p_i$ 为查找第 i 个元素的的概率，n 为查找表中元素的个数，$c_i$ 为找到第 i 个元素所需的关键字比较次数</li>
</ul>
<ol>
<li>顺序查找（线性表）<br>从表的一段向另外一端逐个查找<br><strong>顺序查找方法在查找成功时候的平均比较次数约为表长的一半</strong><br>ASL成功 &#x3D; (n+1)&#x2F;2 , ASL不成功 &#x3D; n ， 平均时间复杂度 &#x3D; O(n)</li>
<li>折半查找（二分查找）不适合链表结构<br>二分查找的时间复杂度是O(logn)<br>但是要求必须是有序表（表中元素按关键字是有序的）<br>查找逻辑如下：<br>(1) 查找区间[low, high], 中点mid &#x3D; [(low + high)&#x2F;2]向下取整，待查找值 k<br>(2) 若 k &#x3D; mid_value, 查找成功<br>(3) 若 k &lt; mid_value, 则该元素在表中 [low, mid - 1] 的区间中, 新查找区间为[low, mid - 1]<br>(4) 若 k &gt; mid_value, 则该元素在表中 [mid + 1, high] 的区间中, 新查找区间为[mid + 1, high]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BinSearch</span>(<span class="params">table, table_len, key</span>):</span><br><span class="line">   low = <span class="number">0</span></span><br><span class="line">   high = table_len - <span class="number">1</span></span><br><span class="line">   mid = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">       mid = (low + high)//<span class="number">2</span></span><br><span class="line">       <span class="keyword">if</span> key == table[mid].key:</span><br><span class="line">           <span class="keyword">return</span> mid</span><br><span class="line">       <span class="keyword">if</span> key &lt; table[mid].key:</span><br><span class="line">           high = mid - <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>: </span><br><span class="line">           low = mid + <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># 当没有查找到的时候，返回-1，代表未找到</span></span><br></pre></td></tr></table></figure>
<strong>折半查找中关键字的比较次数并不是严格的算法中的关键字比较次数，粗略来说应该是key_value与mid中点的比较次数</strong><br>ASL平均查找长度 &#x3D; $log_2(n+1) - 1$ , 时间复杂度$O(log_2n)$<br>对于ASL成功&#x2F;不成功的计算，可以通过画出判定树的方式来计算  <img src="image\binsearch.png" alt="图片描述" style="width:500px;height:500px;">  </li>
<li>索引查找</li>
<li>分块查找<br>对原表进行分块，要求原表是分块有序的，挑选每一块中最大的值作为索引，构建一个索引表<br>思路：首先查找索引表，索引表是有序的，可以使用折半查找或顺序查找，确定待查元素的块位置后，对目标块使用顺序查找</li>
</ol>
<h3 id="树表的查找"><a href="#树表的查找" class="headerlink" title="树表的查找"></a>树表的查找</h3><ol>
<li>二叉排序树（二叉搜索树，binary search tree）<br>满足左子树所有结点值小于等于根节点值，右子树所有结点值大于等于根节点值<br><strong>满足上面性质的树，中序遍历的结果是一个递增有序序列</strong><br>在二叉排序树中进行查找和折半查找比较类似，算法如下  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">SearchBST</span>(<span class="params">node, value</span>):</span><br><span class="line">    <span class="keyword">if</span>(node == null <span class="keyword">or</span> node.value == value):</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">if</span>(value &lt; node.value):</span><br><span class="line">        node = SearchBST(node.lchild, value) <span class="comment"># 小于，在左子树继续查找</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = SearchBST(node.rchild, value) <span class="comment"># 大于，在右子树继续查找</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
在查找过程中，关键字比较的次数不会超过二叉排序树的高度。平均查找长度为$log_2 n$。对于一个二叉排序树，最大节点是根节点右子树的最右结点，最小节点为左子树的最左节点</li>
<li>平衡二叉树（一般指代AVL树）  <ul>
<li>若一个二叉树中每个节点的左右子树的高度最多相差1，则称为平衡二叉树。一颗平衡二叉树总是二叉排序树  </li>
<li>当向平衡二叉树插入一个新节点后，可能会破坏树的平衡性，因此要进行调整。调整类型有LL型调整，RR型调整，LR型调整，RL型调整。前两种比较类似，后两种比较类似  </li>
<li>当要在平衡二叉树中删除一个节点的时候，删除的时候同样要进行调整</li>
<li>含有 n 个结点的平衡二叉树的平均查找长度为$O(log_2n)$</li>
</ul>
</li>
<li>B-和B+树<ul>
<li>区别：二叉排序和二叉平衡树都是用作内查找的数据结构，即查找的数据集不大，可以放在内存中，而B+和B-树都是要做外查找的数据结构，其中数据存放在外存中</li>
</ul>
</li>
<li>红黑树</li>
</ol>
<h3 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h3><ul>
<li>对于元素的关键字k，使用一个哈希函数h(k) 把 k 映射为内存单元的下标h(k)</li>
<li>哈希函数选择方法：<ul>
<li>直接定址法：h(k) &#x3D; k + c</li>
<li>除余留数法：h(k) &#x3D; k mod p, p &lt;&#x3D; 哈希表长度m</li>
</ul>
</li>
<li>哈希查找性能与3个元素有关：<ul>
<li>装填因子Alpha：即为哈希表中已存入的元素数 n 与哈希地址空间大小 m 的比值，alpha &#x3D; n&#x2F;m, aplha在0.6~0.9之间较为合适</li>
<li>哈希函数</li>
<li>哈希冲突</li>
</ul>
</li>
<li>哈希冲突解决方法：<ul>
<li>开放定址法：在出现哈希冲突的时候，在表中找一个新的位置存放元素。<ul>
<li>线性探测法：从发生冲突的地址（下标）开始，探测该地址的下一个位置是否可以进行存放。优点是方法简单，缺点是容易产生堆积问题，即出现哈希数值不同的两个元素争夺同一个地址的现象</li>
<li>平方探测法：发生冲突的地址设为d，则接下来探测位置为d+1^2, d-1^2, d+2^, d-2^2，可以避免出现堆积问题</li>
<li>伪随机序列法，双哈希函数法</li>
</ul>
</li>
<li>拉链法：把所有具有相同哈职数值的元素，用单链表链接起来。优点是处理简单，没有堆积现象，空间动态增加，alpha值可大于1，缺点就是占用额外空间</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第10章-排序"><a href="#第10章-排序" class="headerlink" title="第10章 排序"></a>第10章 排序</h2><ul>
<li>稳定与不稳定的排序算法的区别：若具有相同关键字的元素之间的相对次序发生了变化，则是不稳定的，反之是稳定的</li>
<li>稳定的排序算法：冒泡，直接插入，折半插入，归并，桶排序，基数排序</li>
<li>不稳定的排序算法：快速排序，堆排序，希尔排序，简单选择排序</li>
<li>原地排序的算法（不需要额外存储空间，直接在原始数据存储空间进行排序操作）：冒泡，插入，简单选择，快速，希尔排序(shell)，堆排序</li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">array</span>): <span class="comment"># 递增</span></span><br><span class="line">    array_len = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(array_len):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, array_len-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>]):</span><br><span class="line">                array[j], array[j+<span class="number">1</span>] =array[j+<span class="number">1</span>], array[j] </span><br></pre></td></tr></table></figure>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">array</span>): <span class="comment"># 递增</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        key = array[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> array[j] &gt; key: <span class="comment"># array[j] &lt; key 递减版本</span></span><br><span class="line">            array[j+<span class="number">1</span>] = array[j] <span class="comment"># 将元素集中后移</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        array[j+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递增, 将low = mid+1与high = mid-1调换位置，变为递减版本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_insertion_sort</span>(<span class="params">array</span>): </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        key = array[i]</span><br><span class="line">        low, high = <span class="number">0</span>, i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high: <span class="comment"># 通过二分查找找到合适的插入位置</span></span><br><span class="line">            mid = (low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> array[mid] &lt; key:</span><br><span class="line">                low = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">1</span>, low-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 插入元素到合适的位置</span></span><br><span class="line">            array[j+<span class="number">1</span>] = array[j] <span class="comment"># 将元素集中后移</span></span><br><span class="line">        array[low] = key</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">array</span>): <span class="comment"># 递增，修改left和right的大小号就可以修改为递减</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    </span><br><span class="line">    pivot = array[<span class="built_in">len</span>(array) // <span class="number">2</span>] </span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &gt; pivot] </span><br><span class="line">    <span class="keyword">return</span> quick_sort(left) + middle + quick_sort(right)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[r];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt; r; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; pivot)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i + <span class="number">1</span>], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">        <span class="built_in">quicksort</span>(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quicksort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quicksort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="归并排序-二路归并排序"><a href="#归并排序-二路归并排序" class="headerlink" title="归并排序(二路归并排序)"></a>归并排序(二路归并排序)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">array</span>): <span class="comment"># 递增</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    </span><br><span class="line">    mid = <span class="built_in">len</span>(array) // <span class="number">2</span></span><br><span class="line">    left = array[:mid]</span><br><span class="line">    right = array[mid:]</span><br><span class="line"></span><br><span class="line">    left = merge_sort(left)</span><br><span class="line">    right = merge_sort(right)</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    result = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]: <span class="comment"># 当修改 &lt;= 为 &gt;= 的时候，就变为递减版本</span></span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    result.extend(left[i:])</span><br><span class="line">    result.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">array</span>): <span class="comment"># 递增</span></span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    gap = n // <span class="number">2</span> <span class="comment"># 初始化增量序列为数组长度的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            temp = array[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 和直接插入排序一样，修改为 &lt; 变为递减版本</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> array[j - gap] &gt; temp: </span><br><span class="line">                array[j] = array[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            array[j] = temp</span><br><span class="line"></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">array</span>): <span class="comment"># 递增</span></span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[min_index]: <span class="comment"># 修改为 &gt; 即为递减版本</span></span><br><span class="line">                min_index = j</span><br><span class="line">        array[i], array[min_index] = array[min_index], array[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>小根堆：父节点的值小于或等于其子节点的值。因此，堆的根节点是整个堆中的最小值。 左一为小根根 </li>
<li>大根堆： 父节点的值大于或等于其子节点的值。因此，堆的根节点是整个堆中的最大值。左二为大根堆  </li>
<li>他们都是基于完全二叉树结构的数据结构<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      2                 11</span><br><span class="line">    /   \             /   \</span><br><span class="line">   5     7           7     8</span><br><span class="line">  / \   /           / \   /</span><br><span class="line">11   8 9           3   5 2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用最大堆进行排序的时候，为递增；可以修改为使用最小堆，即为递减</span></span><br><span class="line"><span class="comment"># 修改heapify中array[left] &gt; array[largest]和下面类似句子为 &lt; 即为构造最小堆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">array, n, i</span>):</span><br><span class="line">    largest = i <span class="comment"># 初始化最大值为父节点</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span> <span class="comment"># 左子节点索引</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span> <span class="comment"># 右子节点索引</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> array[left] &gt; array[largest]:</span><br><span class="line">        largest = left <span class="comment"># 比较父节点与左子节点，更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> array[right] &gt; array[largest]:</span><br><span class="line">        largest = right <span class="comment"># 比较父节点与右子节点，更新最大值索引</span></span><br><span class="line">    <span class="keyword">if</span> largest != i: <span class="comment"># 如果最大值索引不等于父节点索引，则交换父节点与最大值节点</span></span><br><span class="line">        array[i], array[largest] = array[largest], array[i]</span><br><span class="line">        heapify(array, n, largest) <span class="comment"># 递归调用，继续向下调整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">array</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 构建大根堆</span></span><br><span class="line">        heapify(array, n, i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 依次将堆顶元素（最大值）与堆尾元素交换，并重新调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        array[i], array[<span class="number">0</span>] = array[<span class="number">0</span>], array[i]</span><br><span class="line">        heapify(array, i, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        nums[index++] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">array, exp</span>): <span class="comment"># 递增，修改对应语句，即从右往左进行累加，就是递减版本</span></span><br><span class="line">    n = <span class="built_in">len</span>(array)</span><br><span class="line">    output = [<span class="number">0</span>] * n </span><br><span class="line">    count = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 计算每个元素的频率</span></span><br><span class="line">        index = array[i] // exp</span><br><span class="line">        count[index % <span class="number">10</span>] += <span class="number">1</span> <span class="comment"># count[9 - (index % 10)]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>): <span class="comment"># 将 count 转换为每个数字在 output 中的实际位置</span></span><br><span class="line">        count[i] += count[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    i = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>: <span class="comment"># 构建排序后的数组</span></span><br><span class="line">        index = array[i] // exp</span><br><span class="line">        output[count[index % <span class="number">10</span>] - <span class="number">1</span>] = array[i] <span class="comment"># count[9 - (index % 10)]</span></span><br><span class="line">        count[index % <span class="number">10</span>] -= <span class="number">1</span> <span class="comment"># count[9 - (index % 10)]</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 将排序后的数组复制到原始数组</span></span><br><span class="line">        array[i] = output[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">array</span>):</span><br><span class="line">    max_value = <span class="built_in">max</span>(array)</span><br><span class="line"></span><br><span class="line">    exp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> max_value // exp &gt; <span class="number">0</span>:</span><br><span class="line">        counting_sort(array, exp)</span><br><span class="line">        exp *= <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">array</span>): <span class="comment"># 递增，动态的根据数组的上下限选择桶的数量，可以修改</span></span><br><span class="line">    num_buckets = <span class="built_in">max</span>(array) // <span class="number">10</span> - <span class="built_in">min</span>(array) // <span class="number">10</span> + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_buckets)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">        index = (num - <span class="built_in">min</span>(array)) // <span class="number">10</span> <span class="comment"># 修改为max(array) - num, 即为递减</span></span><br><span class="line">        buckets[index].append(num)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        bucket.sort() <span class="comment"># </span></span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        result.extend(bucket)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> bucketCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || bucketCount &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 找到数组中的最小值和最大值</span></span><br><span class="line">    <span class="type">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 计算每个桶的范围</span></span><br><span class="line">    <span class="type">double</span> bucketRange = (<span class="type">double</span>)(maxVal - minVal) / bucketCount;</span><br><span class="line">    <span class="comment">// 创建桶，使用优先队列（小顶堆）模拟桶</span></span><br><span class="line">    vector&lt;priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">buckets</span>(bucketCount);</span><br><span class="line">    <span class="comment">// 将元素分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> bucketIndex = (<span class="type">int</span>)((num - minVal) / bucketRange);</span><br><span class="line">        <span class="keyword">if</span> (bucketIndex == bucketCount) bucketIndex--; <span class="comment">// 边界情况</span></span><br><span class="line">        buckets[bucketIndex].<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集排序结果</span></span><br><span class="line">    nums.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!bucket.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(bucket.<span class="built_in">top</span>());</span><br><span class="line">            bucket.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O($nlog_2n$)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O($n + k$)</td>
<td>O(n + k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O($d(n+r)$)</td>
<td>O(r)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O($nlog_2n$)</td>
<td>O($log_2n$)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O($nlog_2n$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O($n^1.3$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody></table>
<p>备注：基数排序，数据位数 d , 进制为 r</p>
<hr>
<h2 id="第8章-图"><a href="#第8章-图" class="headerlink" title="第8章 图"></a>第8章 图</h2><ul>
<li>图由顶点（vertex）和边（edge）构成，记一张图为 G &#x3D; (V, E)</li>
<li>有向图：表示边的顶点对是有序的，无向图：表示边的顶点对是无序的。通过边有没有方向来区分</li>
<li>无向图中，一个顶点关联的边的数目成为顶点的度。若为有向图，则分为出度和入度。一个图中所有顶点的度之和等于边数的两倍</li>
<li>完全图：每两个顶点存在一条边（有向图则存在两条边）。无向完全图有 n(n-1)&#x2F;2 条边，有向完全图有 n(n-1) 条边</li>
<li>无向图中，若任意两点存在一个路径，则为连通图。有向图中，若任意两点存在路径，成为强连通图</li>
<li>图的邻接矩阵存储方法，图的邻接矩阵表示是<strong>唯一的</strong></li>
<li>图的邻接表存储方法，对每个顶点建立一个单链表，分为头结点和边结点。邻接表的表示不唯一</li>
<li>图的遍历：分为深度优先遍历（DFS）和广度优先遍历（BFS）</li>
</ul>
<h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><p>从一个顶点 v 出发，选择一个与v相邻的且没被访问过的顶点 w 访问，然后对顶点 w 递归进行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">graph, start, visited=<span class="literal">None</span></span>): <span class="comment"># 邻接表存储方法</span></span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="built_in">print</span>(start, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[start]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            DFS(graph, neighbor, visited)</span><br></pre></td></tr></table></figure>
<p>对于有 n 个顶点，e 条边的有向图或者无向图，DFS算法对每个顶点最多调用一次，所以递归调用的总次数为 n  </p>
<ul>
<li>邻接表表示图时，总时间为 O(n+e)</li>
<li>邻接矩阵表示图时， 为 O(n^2)</li>
</ul>
<h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>从一个顶点出发，访问该顶点所有未被访问过的邻接点，再按访问的邻接点顺序访问</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">graph, start</span>): <span class="comment"># 邻接表存储方法</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = deque([start])</span><br><span class="line">    visited.add(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        vertex = queue.popleft()</span><br><span class="line">        <span class="built_in">print</span>(vertex, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[vertex]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                queue.append(neighbor)</span><br><span class="line">                visited.add(neighbor)</span><br></pre></td></tr></table></figure>
<ul>
<li>邻接表表示图时，总时间为 O(n+e)</li>
<li>邻接矩阵表示图时， 为 O(n^2)</li>
</ul>
<h3 id="生成树与算法"><a href="#生成树与算法" class="headerlink" title="生成树与算法"></a>生成树与算法</h3><ul>
<li>生成树（Spanning Tree）是一个连通图的一种特殊子图，它包含图中的所有顶点，并且是一个树结构，即没有包含环路的连通子图</li>
<li>图的所有生成树中具有边上的权值之和最小的树成为图的最小生成树</li>
<li>根据生成树定义，n 个顶点的连通图生成树有 n 个顶点，(n-1) 条边</li>
<li>采用BFS或DFS算法遍历图的时候，就可以得到一颗生成树，分别为广度优先生成树和深度优先生成树</li>
</ul>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><ul>
<li>这是一个构造算法，可以基于一个带权的连通图构造最小生成树</li>
<li>prim算法适用于图的邻接矩阵存储方式</li>
<li>时间复杂度为 O(n^2), n 为顶点个数，prim算法执行时间与边个数无关，适合稠密图<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prim</span>(<span class="params">graph</span>):</span><br><span class="line">    num_verticse = <span class="built_in">len</span>(graph)</span><br><span class="line">    isin_tree = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * num_verticse <span class="comment"># 记录点是否在集合里面</span></span><br><span class="line">    isin_tree[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    parent = [<span class="literal">None</span>] * num_verticse <span class="comment"># 记录每一条边的左端点，后面打印用的</span></span><br><span class="line">    mst_set = [<span class="literal">False</span>] * num_verticse <span class="comment"># 记录最小距离的数组</span></span><br><span class="line"></span><br><span class="line">    parent[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_verticse):</span><br><span class="line">        Min = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        Min_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_verticse):</span><br><span class="line">            <span class="keyword">if</span> isin_tree[j] &lt; Min <span class="keyword">and</span> mst_set[j] == <span class="literal">False</span>:</span><br><span class="line">                Min = isin_tree[j]</span><br><span class="line">                Min_index = j</span><br><span class="line">        mst_set[Min_index] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># print(f&quot;边(&#123;node_set[Min_index]&#125;, &#123;Min_index&#125;), 权为&#123;Min&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_verticse):</span><br><span class="line">            <span class="keyword">if</span> graph[Min_index][j] &gt; <span class="number">0</span> <span class="keyword">and</span> mst_set[j] == <span class="literal">False</span> <span class="keyword">and</span> isin_tree[j] &gt; graph[Min_index][j]:</span><br><span class="line">                isin_tree[j] = graph[Min_index][j]</span><br><span class="line">                parent[j] = Min_index <span class="comment"># 多出来的一步，用来记录边的左端点用的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_verticse):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;边(<span class="subst">&#123;parent[i]&#125;</span>, <span class="subst">&#123;i&#125;</span>), 权为<span class="subst">&#123;graph[i][parent[i]]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">    边(<span class="number">0</span>, <span class="number">1</span>), 权为<span class="number">2</span></span><br><span class="line">    边(<span class="number">1</span>, <span class="number">2</span>), 权为<span class="number">3</span></span><br><span class="line">    边(<span class="number">0</span>, <span class="number">3</span>), 权为<span class="number">6</span></span><br><span class="line">    边(<span class="number">1</span>, <span class="number">4</span>), 权为<span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">min_dist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>; </span><br><span class="line">    <span class="comment">// 题目中说val最大值是10001，因此设置为10001没问题</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isin_tree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 只需要进行v-1次循环就可以得到，因为有v个点，那么只需要v-1条边，就可以</span></span><br><span class="line">    <span class="comment">// 把这v个点全部链接起来，每次循环链接一条边，所以只需要循环v-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; v; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> min_dist_value = INT_MAX; <span class="comment">// 要用INT_MAX，需要#include&lt;climits&gt;</span></span><br><span class="line">        <span class="comment">// 下面这个循环是找到一个距离当前最小生成树距离最短的一个端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isin_tree[j] &amp;&amp; min_dist[j] &lt; min_dist_value)&#123;</span><br><span class="line">                cur = j;</span><br><span class="line">                min_dist_value = min_dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        isin_tree[cur] = <span class="literal">true</span>; <span class="comment">// 将上面找到的点(cur)加入路径，在下面循环的时候就不会被找到了</span></span><br><span class="line">        <span class="comment">// 在下面这个循环中，更新min_dist数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isin_tree[j] &amp;&amp; graph[cur][j] &lt; min_dist[j] &amp;&amp; graph[cur][j] != <span class="number">0</span>)&#123; <span class="comment">// 找不在isin_tree中的点，同时距离还小，同时不等于0（等于0表示没有这条路径）</span></span><br><span class="line">                min_dist[j] = graph[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部信息保存在min_dist数组中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><ul>
<li>按权值递增次数选择合适的边来构造最小生成树的算法</li>
<li>prim和kruskal产生的最小生成树不一定是相同的</li>
<li>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合</li>
<li>稀疏图中，用Kruskal更优。 在稠密图中，用prim算法更优</li>
<li>kruskal算法执行时间只与边数e有关，适合稀疏图</li>
<li>时间复杂度为 O(e^2), 改进后可以变为 O($elog_2e$)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">edges = [(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;A&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="number">7</span>),</span><br><span class="line">         (<span class="string">&quot;B&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;C&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">4</span>),</span><br><span class="line">         (<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;C&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">7</span>),</span><br><span class="line">         (<span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">4</span>),</span><br><span class="line">         (<span class="string">&quot;E&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="number">12</span>),(<span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="number">12</span>)]</span><br><span class="line">vertices=<span class="built_in">list</span>(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line">edges.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">2</span>])</span><br><span class="line">mst = [] <span class="comment"># 最小生成树</span></span><br><span class="line">ori_trees=<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> vertices:</span><br><span class="line">    ori_trees[i] = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_node</span>(<span class="params">x</span>): <span class="comment"># 寻找根节点</span></span><br><span class="line">    <span class="keyword">if</span> ori_trees[x] != x:</span><br><span class="line">        ori_trees[x] = find_node(ori_trees[x])</span><br><span class="line">    <span class="keyword">return</span> ori_trees[x]</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(vertices) - <span class="number">1</span> <span class="comment"># 要添加的边数为顶点数 - 1</span></span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">    v1, v2, weight = edge</span><br><span class="line">    <span class="keyword">if</span> find_node(v1) != find_node(v2):</span><br><span class="line">        ori_trees[find_node(v2)] = find_node(v1)</span><br><span class="line">        mst.append(edge)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;添加边(<span class="subst">&#123;v1&#125;</span>, <span class="subst">&#123;v2&#125;</span>), 权为<span class="subst">&#123;weight&#125;</span>&quot;</span>)</span><br><span class="line">        n-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小生成树为&quot;</span>, mst)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++版本kruskal算法，需要并查集模板（3个函数，find, isSame, join), 还需要#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">(vector&lt;edge&gt;&amp; edges, <span class="type">int</span> edge_num, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = v - <span class="number">1</span>; <span class="comment">// 只需要循环v-1次，就能链接v个顶点</span></span><br><span class="line">    vector&lt;edge&gt; tree; <span class="comment">// 保存了最小生成树的每一条边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; edge_num; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isSame</span>(edges[i].l, edges[i].r))&#123; <span class="comment">//两点不在一个集合，可加入</span></span><br><span class="line">            <span class="built_in">join</span>(edges[i].l, edges[i].r); <span class="comment">// 加入集合</span></span><br><span class="line">            tree.<span class="built_in">push_back</span>(edges[i]); <span class="comment">// 加入最小生成树</span></span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 循环了v-1次的时候就停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;edge&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;value;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;v1, v2, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> edge&amp; a, <span class="type">const</span> edge&amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;); <span class="comment">// 把edge按照从小到大进行排序，lambda表达式实现</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kruskal</span>(edges, e, v); <span class="comment">// e = edges.size(), v = 顶点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>给出一个有向图，把这个有向图转成线性的排序，就叫拓扑排序</li>
<li>如果这个有向图中有环，那么就不能做线性排序了</li>
<li>拓扑排序也是图论中判断有向无环图的常用方法</li>
<li>拓扑排序是解决图论中依赖关系的方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topology_sort</span><span class="params">(unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; input_rank, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 记录结果</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que; <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(input_rank[i] == <span class="number">0</span>) <span class="comment">// 把入度为0的节点全部放入队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// cur这个节点入度为0，下一步要消除cur节点相关的节点的入度</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(cur); </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur_edges = edges[cur]; <span class="comment">// 获取cur节点相关的右端点</span></span><br><span class="line">        <span class="keyword">if</span>(cur_edges.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur_edges.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                input_rank[cur_edges[i]]--; <span class="comment">// 把cur节点相关的节点入度-1</span></span><br><span class="line">                <span class="keyword">if</span>(input_rank[cur_edges[i]] == <span class="number">0</span>)&#123; <span class="comment">// 如果-1后入度为0，那么也放入队列中 </span></span><br><span class="line">                    que.<span class="built_in">push</span>(cur_edges[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="built_in">size</span>() != n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 如果result的数量和图中节点数量不同，那就说明有环了，无法找到入度为0的节点了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">input_rank</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个节点的入度</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; edges; <span class="comment">// 记录每个节点，以左端点为key，右端点的值放入vector数组中，如&lt;1, [2, 3]&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        input_rank[v2]++;</span><br><span class="line">        edges[v1].<span class="built_in">push_back</span>(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topology_sort</span>(edges, input_rank, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><ul>
<li>不适合含有负权值的带权图进行求解</li>
<li>采用邻接矩阵进行存储的图，或者使用优先队列进行优化的时候，可以使用邻接表</li>
<li>时间复杂度 O(nlogn)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="comment"># 这个版本就是dijkstra的堆优化版本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start</span>):</span><br><span class="line">    distances = &#123;node: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> node <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[start] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 使用优先队列（堆）来保存待访问的节点和其距离</span></span><br><span class="line">    pq = [(<span class="number">0</span>, start)]</span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        <span class="comment"># 从优先队列中取出距离最短的节点</span></span><br><span class="line">        current_distance, current_node = heapq.heappop(pq)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果当前节点已经被访问过，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_node]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历当前节点的邻居节点，并更新其最短距离</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_node].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line">            <span class="comment"># 如果新的距离比已有距离小，则更新距离字典和优先队列，由于优先队列的性质，push进元素的时候会自动进行调整的</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                heapq.heappush(pq, (distance, neighbor))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>: &#123;<span class="string">&#x27;D&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">min_dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// 记录每个节点到节点0的最短距离</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录已经被访问的结点</span></span><br><span class="line">    min_dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 初始化第一个节点距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min_distance = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j)&#123; <span class="comment">// 找到一个没访问过的节点，同时离节点0距离最短的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(visited[j] != <span class="literal">true</span> &amp;&amp; min_dist[j] &lt; min_distance)&#123;</span><br><span class="line">                cur = j;</span><br><span class="line">                min_distance = min_dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>; <span class="comment">// 标记cur结点已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[cur][j] != <span class="number">0</span> &amp;&amp; visited[j] == <span class="literal">false</span> &amp;&amp; min_dist[cur] + graph[cur][j] &lt; min_dist[j])&#123;</span><br><span class="line">                min_dist[j] = min_dist[cur] + graph[cur][j];</span><br><span class="line">                <span class="comment">// 更新min_dist数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有结点到结点0的最短距离都保存在min_dist数组中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> source, vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// 存储从源点到各点的最短距离</span></span><br><span class="line">    dist[source] = <span class="number">0</span>;            <span class="comment">// 起点到自身距离为0</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq; <span class="comment">// 最小堆</span></span><br><span class="line">    pq.<span class="built_in">emplace</span>(<span class="number">0</span>, source);       <span class="comment">// &#123;当前最短距离, 节点编号&#125;</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_dist, u] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_dist &gt; dist[u]) <span class="keyword">continue</span>; <span class="comment">// 如果当前距离已经不是最优解，跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [v, weight] : graph[u]) &#123; <span class="comment">// 遍历所有邻居</span></span><br><span class="line">            <span class="keyword">if</span> (dist[u] + weight &lt; dist[v]) &#123; <span class="comment">// 如果从 u 到 v 的距离更短，更新距离</span></span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(dist[v], v); <span class="comment">// 把新的最短距离和节点加入优先队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman-ford算法"></a>Bellman-ford算法</h4><ul>
<li>可以针对带负权值问题</li>
<li>循环n-1次，每一次循环，都对每一条边做了一次松弛操作<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// edges储存所有的边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">min_dist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">// 所有的路径信息储存在min_dist数组中</span></span><br><span class="line">    min_dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1,v2,val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;&amp; edge:edges)&#123;</span><br><span class="line">            v1 = edge[<span class="number">0</span>];</span><br><span class="line">            v2 = edge[<span class="number">1</span>];</span><br><span class="line">            val = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(min_dist[v1] != INT_MAX &amp;&amp; min_dist[v2] &gt; min_dist[v1] + val)&#123;</span><br><span class="line">                min_dist[v2] = min_dist[v1] + val; <span class="comment">// 松弛操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h4><ul>
<li>对于bellman-ford算法，在每一次循环的松弛过程中，做了很多次不会进行的松弛操作，因此SPFA就是针对这一点应运而生</li>
<li>SPFA算法的松弛过程如下：维护一个队列，只对上一次松弛的时候更新过的节点作为出发节点所连接的边，进行松弛。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;edge&gt;&gt; graph; <span class="comment">// 使用了vector,list,自定义数据结构edge</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que; <span class="comment">// 部分核心代码，主要使用队列就可以</span></span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> node = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">    isInQueue[node] = <span class="literal">false</span>; <span class="comment">// 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span></span><br><span class="line">    <span class="keyword">for</span> (Edge edge : grid[node]) &#123;</span><br><span class="line">        <span class="type">int</span> from = node;</span><br><span class="line">        <span class="type">int</span> to = edge.to;</span><br><span class="line">        <span class="type">int</span> value = edge.val;</span><br><span class="line">        <span class="keyword">if</span> (minDist[to] &gt; minDist[from] + value) &#123; <span class="comment">// 开始松弛</span></span><br><span class="line">            minDist[to] = minDist[from] + value; </span><br><span class="line">            <span class="keyword">if</span> (isInQueue[to] == <span class="literal">false</span>) &#123; <span class="comment">// 已经在队列里的元素不用重复添加</span></span><br><span class="line">                que.<span class="built_in">push</span>(to);</span><br><span class="line">                isInQueue[to] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>特殊情况：如果存在一个环，同时这个环所有的边的权值都是负的，就称为一个负权回路。负权回路会导致无解的情况，因为只要一直在这个环中循环，就可以得到无限小的路径长度</li>
<li>解决方法：<ul>
<li>对于bellman-ford算法，只需要松弛n-1次就可以得到结果，如果没有负权回路，那么无论再松弛多少次，min_dist数组不会变。如果有负权回路，min_dist数组会一直变，可以在做完n-1循环后，再做一次松弛查看是否变化。</li>
<li>对于SPFA算法：如没有负权回路，每个节点最多加入队列n-1次，如果有节点加入队列超过n-1次，那就说明有负权回路</li>
</ul>
</li>
</ul>
<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><ul>
<li>时间复杂度 O(V^3), V为节点个数</li>
<li>可以处理负权值的带权有向图，是一个求多个起点多个终点之间最短路径的算法</li>
<li>维护两个数组，distance数组和path数组，distance数组表示点之间的距离，path数组表示点之间的路径，Path数组中，若Path[0][2] &#x3D; 3，代表2节点的前一个节点是3，若Path[0][3] &#x3D; 0, 则代表已经找到了起点，这条路径是 0 -&gt; 3 -&gt; 2, 再到distance[0][2]读取出最短路径</li>
<li>主要的过程，对于图中所有的点，逐个进行遍历。比如，当进行到A点的时候，将A作为中转站，比如原来BD的路径，则计算AB + BD之间路径的长度，如果更小，则更新distance数组与path数组，逐个进行，可以得到有向图中所有点之间相互的最短距离<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">floyd</span>(<span class="params">graph</span>):</span><br><span class="line">    <span class="comment"># 初始化距离矩阵</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph) <span class="comment"># n为图中结点个数</span></span><br><span class="line">    dist = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                dist[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">                dist[i][j] = graph[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Floyd 算法核心部分</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> dist[i][k] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">and</span> dist[k][j] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="number">0</span>: &#123;<span class="number">1</span>: <span class="number">5</span>, <span class="number">2</span>: <span class="number">9</span>, <span class="number">4</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="number">1</span>: &#123;<span class="number">0</span>: <span class="number">5</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">7</span>&#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;<span class="number">0</span>: <span class="number">9</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">6</span>&#125;,</span><br><span class="line">    <span class="number">3</span>: &#123;<span class="number">1</span>: <span class="number">7</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">8</span>&#125;,</span><br><span class="line">    <span class="number">4</span>: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">6</span>, <span class="number">3</span>: <span class="number">8</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dist数组为两个点的距离，最后的结果也保存在dist数组中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dist, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; target, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; n + <span class="number">1</span>; ++k)&#123; <span class="comment">// k就是中转节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i)&#123; <span class="comment">// 左端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j)&#123; <span class="comment">// 右端点</span></span><br><span class="line">                <span class="keyword">if</span>(dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX)&#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                &#125; <span class="comment">// i是左，j是右，k是中转</span></span><br><span class="line">            &#125;     <span class="comment">// 所以才要判断ik, kj是不是有路径，若有比最小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Astar算法"><a href="#Astar算法" class="headerlink" title="Astar算法"></a>Astar算法</h4><ul>
<li>是一种BFS的改良版本，主要用到了启发式函数，适合无权图(或权全为1的图)，是一种搜索最短路径的方法</li>
<li>由于是启发式算法，结果不一定是最短路径，同时结果也不唯一</li>
<li>主要用到3种启发式函数，优先队列（用于排序）<ul>
<li>x1,y1为起点，x2,y2为终点</li>
<li>曼哈顿距离，计算方式： d &#x3D; abs(x1-x2)+abs(y1-y2)</li>
<li><strong>欧氏距离（欧拉距离）</strong> ，计算方式：d &#x3D; sqrt( (x1-x2)^2 + (y1-y2)^2 ) </li>
<li>切比雪夫距离，计算方式：d &#x3D; max(abs(x1 - x2), abs(y1 - y2))</li>
</ul>
</li>
<li>利用这些来计算每个节点的权值，放到优先队列里面，就能保证每次出队列的是最合适的下一个节点了</li>
<li>时间复杂度大概为O(nlogn), n为节点数量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Knight</span>&#123; <span class="comment">// 自定义数据结构，定义了优先队列的排序顺序</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">int</span> g,h,f; <span class="comment">// f是主要权值，f = g + h</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Knight &amp; k) <span class="type">const</span>&#123;  <span class="comment">// 重载运算符， 从小到大排序</span></span><br><span class="line">     <span class="keyword">return</span> k.f &lt; f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">astar</span><span class="params">(<span class="type">const</span> Knight&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Knight cur, next;</span><br><span class="line">	que.<span class="built_in">push</span>(k);</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cur=que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(cur.x == b1 &amp;&amp; cur.y == b2)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			next.x = cur.x + dir[i][<span class="number">0</span>];</span><br><span class="line">			next.y = cur.y + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(next.x &lt; <span class="number">1</span> || next.x &gt; <span class="number">1000</span> || next.y &lt; <span class="number">1</span> || next.y &gt; <span class="number">1000</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!moves[next.x][next.y]) <span class="comment">// next这个点没有被访问过</span></span><br><span class="line">			&#123;</span><br><span class="line">				moves[next.x][next.y] = moves[cur.x][cur.y] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 开始计算F</span></span><br><span class="line">				next.g = cur.g + <span class="number">5</span>; <span class="comment">// 统一不开根号，这样可以提高精度</span></span><br><span class="line">                next.h = <span class="built_in">Heuristic</span>(next);</span><br><span class="line">                next.f = next.g + next.h;</span><br><span class="line">                que.<span class="built_in">push</span>(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="image\最短路径算法图解.png" alt="图片描述"></li>
</ul>
<hr>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><ul>
<li>分为目标串(traget string), 模式串(pattern string), 在目标串中找到模式串</li>
</ul>
<h3 id="Brute-Force算法"><a href="#Brute-Force算法" class="headerlink" title="Brute-Force算法"></a>Brute-Force算法</h3><ul>
<li>重复进行搜索即可，时间复杂度为 O(nm), n 为模式串程度，m 为目标串程度</li>
</ul>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li>计算next数组的串是模式串，在里面找的串是目标串</li>
<li>分为两部分，next数组和搜索过程。首先根据模式串计算出next数组，然后进行搜索</li>
<li>消除了主串指针的回溯</li>
<li>next数组：<br>从模式串的第i位开始，对str[0:i]的头部和尾部求最长公共部分，比如abcabaa这个串，它的next数组是{0, 0, 0, 1, 2, 1, 1}</li>
<li>在搜索过程中，有两个指针，i 和 j，i 为目标串的指针，j 为模式串的指针，当发生失配（匹配失败）的时候，i 不变，将 j 赋值为 next[j] 进行更新，重复这个过程。i指针始终向前，而j指针通过Next数组控制回溯和跳转</li>
<li>时间复杂度为 O(n+m)</li>
</ul>
<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li><p><strong>二叉树节点的深度</strong>：指从根节点到该节点的最长简单路径边的条数</p>
</li>
<li><p><strong>二叉树节点的高度</strong>：指从该节点到叶子节点的最长简单路径边的条数</p>
<ul>
<li>一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点</li>
</ul>
</li>
<li><p>二叉排序树，平衡二叉排序树(AVL)，二叉搜索树相关的算法在45行</p>
</li>
<li><p>二叉排序树：插入节点后一定是叶子结点，不需要调整</p>
</li>
<li><p>平衡二叉排序树：左右两个子树之间的高度差不大于1，插入节点后需要调整</p>
<ul>
<li>可以通过一个有序数组来构建一个平衡二叉排序树<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nums是一个递增的数组, left = 0, right = len(nums) - 1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">  <span class="keyword">if</span> left &gt; right:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">  mid = left + ((right - left) // <span class="number">2</span>) <span class="comment"># 二分法也可以这么写，防止数组越界</span></span><br><span class="line">  root = TreeNode(nums[mid]) <span class="comment"># 选择数组中心的点来进行创建，将当前数组分割为左右两个数组</span></span><br><span class="line">  <span class="comment"># 注意分割后的数组区间</span></span><br><span class="line">  root.left = <span class="variable language_">self</span>.build(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">  root.right = <span class="variable language_">self</span>.build(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">  <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二叉搜索树 &#x3D; 二叉排序树 &#x3D; 二叉查找树 &#x3D; BST</p>
<ul>
<li>BST的中序遍历结果是一个递增的序列</li>
<li>BST的反中序遍历的结果是一个递减的序列</li>
<li>左子树节点小于父节点，右子树节点大于父节点(不能是大于等于或者是小于等于)</li>
</ul>
</li>
<li><p>二叉树的公共祖先问题：即对于一个节点，若是左子树出现节点p，右子树出现节点q，则该节点为p和q的公共祖先</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">root, p, q</span>):</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">  </span><br><span class="line">  node1 = find()</span><br><span class="line">  node2 = find()</span><br><span class="line">  <span class="comment"># 如果node1和node2不为空，返回root</span></span><br><span class="line">  <span class="comment"># 如果node1和node2之间有个为空，返回不为空的那个</span></span><br><span class="line">  <span class="comment"># 都为空，返回None</span></span><br></pre></td></tr></table></figure></li>
<li><p>深度优先遍历：</p>
<ul>
<li>先序遍历：先访问根节点，然后左子树，然后右子树</li>
<li>中序遍历：先访问左子树，然后根节点，然后右子树</li>
<li>后序遍历：先访问左子树，然后右子树，然后根节点(带有回溯特征，即可以根据左右子树的返回结果来进行一些操作)</li>
<li>上面这三种遍历主要使用递归的方式进行，当然也可以使用栈对递归进行模拟，修改为迭代的形式</li>
</ul>
</li>
<li><p>广度优先遍历：</p>
<ul>
<li>层次遍历：先访问根节点，然后从上到下从左到右进行访问  </li>
<li>一般使用队列来进行实现，由于队列先进先出的特点，可以实现一层一层的遍历二叉树<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="comment"># 十分重要！</span></span><br><span class="line">queue = collections.deque([root]) <span class="comment"># 直接使用队列</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">while</span> queue:</span><br><span class="line">  level = []</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">      cur = queue.popleft()</span><br><span class="line">      result.append(cur.val)</span><br><span class="line">      <span class="keyword">if</span> cur.left:</span><br><span class="line">          queue.append(cur.left)</span><br><span class="line">      <span class="keyword">if</span> cur.right:</span><br><span class="line">          queue.append(cur.right)</span><br><span class="line">  result.append(level)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">order_0</span>(<span class="params">node</span>): <span class="comment"># 递归版本</span></span><br><span class="line">    <span class="built_in">print</span>(node.value) <span class="comment"># 先序遍历</span></span><br><span class="line">    order(node.lchild)</span><br><span class="line">    order(node.rchild)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order_1</span>(<span class="params">node</span>): <span class="comment"># 非递归版本，使用栈</span></span><br><span class="line"><span class="comment"># 将根节点进栈</span></span><br><span class="line"><span class="comment"># while(栈不空)：</span></span><br><span class="line"><span class="comment"># 出栈一个节点p，访问打印信息</span></span><br><span class="line"><span class="comment"># 若该节点p有右子节点，进栈p.rchild</span></span><br><span class="line"><span class="comment"># 若该节点p有左子结点，进栈p.lchild</span></span><br><span class="line">stack.push(node)</span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">while</span>(stack.empty() == false):</span><br><span class="line">    curr_node = stack.pop()</span><br><span class="line">    ans.append(curr_node.val)</span><br><span class="line">    <span class="keyword">if</span>(curr_node.right != null): stack.push(curr_node.right)</span><br><span class="line">    <span class="keyword">if</span>(curr_node.left != null): stack.push(curr_node.left)</span><br><span class="line"><span class="comment"># 若层次遍历，则使用队列，基本原理一样，队列先进先出</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以通过前序(preorder)+中序(inorder)或者后序(postorder)+中序来建立一棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">traversal</span>(<span class="params">self, in_order, post_order</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(post_order) == <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">      </span><br><span class="line">      index = in_order.index(post_order[-<span class="number">1</span>])</span><br><span class="line">      root = TreeNode(post_order[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(post_order) == <span class="number">1</span>:</span><br><span class="line">          <span class="keyword">return</span> root</span><br><span class="line">      </span><br><span class="line">      left_inorder = in_order[:index]</span><br><span class="line">      right_inorder = in_order[index + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">      left_postorder = post_order[:<span class="built_in">len</span>(left_inorder)]</span><br><span class="line">      right_postorder = post_order[<span class="built_in">len</span>(left_inorder):<span class="built_in">len</span>(left_inorder) + <span class="built_in">len</span>(right_inorder)]</span><br><span class="line"></span><br><span class="line">      root.left = <span class="variable language_">self</span>.traversal(left_inorder, left_postorder)</span><br><span class="line">      root.right = <span class="variable language_">self</span>.traversal(right_inorder, right_postorder)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder, postorder</span>):</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      :type inorder: List[int]</span></span><br><span class="line"><span class="string">      :type postorder: List[int]</span></span><br><span class="line"><span class="string">      :rtype: TreeNode</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">len</span>(inorder) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(postorder) == <span class="number">0</span>):</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">self</span>.traversal(inorder, postorder)</span><br></pre></td></tr></table></figure></li>
<li><p>合并两棵树：使用各种遍历方法都可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, root1, root2</span>):</span><br><span class="line">  <span class="keyword">if</span> root1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> root2</span><br><span class="line">  <span class="keyword">if</span> root2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> root1</span><br><span class="line">  </span><br><span class="line">  root1.val += root2.val</span><br><span class="line">  root1.left = <span class="variable language_">self</span>.merge(root1.left, root2.left)</span><br><span class="line">  root1.right = <span class="variable language_">self</span>.merge(root1.right, root2.right)</span><br><span class="line">  <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="并查集操作-Union-find"><a href="#并查集操作-Union-find" class="headerlink" title="并查集操作(Union find)"></a>并查集操作(Union find)</h3><ul>
<li>需要经常使用查找，合并集合的操作，可以使用树的方法来实现并查集。 </li>
<li>用有根树来表示集合，树中每一个节点表示集合的一个元素，每一颗树表示一个集合，所有的树构成一根森林</li>
<li>在合并两棵树的时候，可以让树高度较小的树成为树高度较大树的子树，这样就能实现比较平衡的树</li>
<li>在树中，每个节点都存在一个父亲节点，可以定义父亲节点为自己的节点为根节点，也代表了这棵树，代表了一个集合</li>
<li>主要定义三个操作：Find(type x)和Union(type x, type y)和isSame(type x, type y), 分为查找元素，合并元素，判断2个元素是否是同一个集合</li>
<li>路径压缩：当查找到根节点后，沿着路径改变所有节点的父指针，使其全部指向根节点。意思是比如2是根节点，4-&gt;3-&gt;5-&gt;2, 在2这个集合里面有3,4,5三个元素，经过路径压缩后，就会变成：4-&gt;2, 3-&gt;2, 5-&gt;2，这样子就会减少查找的深度</li>
<li>并查集find，join操作的时间复杂度是$O(\alpha(N))$, $\alpha(N)$是反阿克曼函数，几乎是常数，所以find和join操作时间复杂度可以看为是O(1)，而初始化时间复杂度是O(N)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++ 并查集模板</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// 长度根据题目中节点数量而定</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father; <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"><span class="comment">// 并查集初始化，全部初始化为自身</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span>: father(n) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找。在查询的过程中会自动进行路径压缩，减小下一次查询的开销</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u; <span class="comment">// 代表v的根是u，u -&gt; v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三元组操作"><a href="#三元组操作" class="headerlink" title="三元组操作"></a>三元组操作</h3><ul>
<li>可以储存稀疏矩阵，以一个n * m的矩阵为例，假设存储的是int类型的数据，共存储10个</li>
<li>以（行，列，数据）的方式存储一个数据，一个数据消耗6个字节，同时，另外需要6个字节来存储数组的行数，列数，数据个数</li>
<li>所以存储10个数据一共需要60+6&#x3D;66个字节</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>设序列进栈顺序为x1, x2, x3,…, 有多少种出栈顺序？<br>可能的结果有1, 2, 5, 14, 42, 132, 429, 对应元素个数为1,2,3,4,5,6,7</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>可以使用2个栈来模拟一个队列，一个instack，一个outstack。当push数据，直接push到instack中。当pop或者top数据的时候，如果outstack为空，把instack所有数据取出并压入outstack，然后再从outstack中取数据</li>
</ul>
<h3 id="B-树-B树"><a href="#B-树-B树" class="headerlink" title="B+树&#x2F;B树"></a>B+树&#x2F;B树</h3><ul>
<li>B树（B-Tree）是一种自平衡的多叉搜索树，主要用于数据库和文件系统中，以加快数据的读写速度。它的特点是：<ul>
<li>多叉节点：每个节点可以包含多个键和多个子节点，而不是像二叉树那样仅包含两个子节点。</li>
<li>节点间有序性：每个节点的键按照大小排序，子节点按顺序放置在相应的键之间。</li>
<li>平衡性：B树始终保持平衡，即从根到叶子的路径长度相同，避免了长链表状的单边增长。</li>
<li>可配置的阶数：阶数（即每个节点的子节点数）可以根据需求设置，以调整树的分支数量和高度。<br>  B树的这种结构让它能有效地减少磁盘IO操作，因为节点较少，访问特定数据时可以跳过大部分无关数据。B树在写入和删除数据时，会通过分裂和合并节点来保持平衡</li>
</ul>
</li>
<li>B+树（B+ Tree）是B树的一种变体，改进了数据的存储方式，进一步提高了数据的查找效率。B+树在B树的基础上增加了以下特点：<ul>
<li>所有数据存储在叶子节点：B+树的非叶子节点只存储键而不存储数据，所有数据都保存在叶子节点中。这样可以让树的内部节点更轻量，增加分支因子，从而降低树的高度。</li>
<li>叶子节点间的链表结构：B+树的叶子节点通过指针相连，形成一个有序的链表。这样在范围查找时，可以从起始叶子节点顺序访问，速度更快。每个叶子节点有两个指针，指向下一个和上一个叶子节点，形成一个双向链表</li>
<li>查询速度更稳定：由于数据都存储在同一层的叶子节点上，B+树的查询效率更加稳定。<br>  B+树的结构非常适合范围查询等操作，数据的顺序性和叶子节点的链接，使得区间查找在B+树中只需进行一次磁盘扫描。</li>
</ul>
</li>
</ul>
<h3 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red-Black Tree）"></a>红黑树（Red-Black Tree）</h3><ul>
<li><strong>节点颜色</strong>：每个节点都被着色为红色或黑色。</li>
<li><strong>根节点</strong>：根节点始终是黑色的。</li>
<li><strong>叶节点</strong>：所有叶节点（NIL节点）都是黑色的。</li>
<li><strong>红色节点的限制</strong>：红色节点不能连续出现，即一个红色节点的子节点必须是黑色。</li>
<li><strong>黑色平衡</strong>：从任何一个节点到其所有子孙叶节点的路径上，必须包含相同数量的黑色节点。</li>
<li>插入后可能需要通过<strong>重新着色</strong>和<strong>旋转</strong>来保持红黑树的性质。</li>
<li><strong>查找、插入、删除</strong>操作的时间复杂度：O(logn)，其中n为树中的节点数。</li>
<li><strong>与AVL树的比较</strong>：红黑树比AVL树稍微简单一些，因为它不要求每个节点的平衡因子严格为-1、0或1，而是要求红黑性质，但保持平衡的代价较小。</li>
<li><strong>与普通二叉查找树的比较</strong>：普通二叉查找树的最坏时间复杂度为O(n)，而红黑树保证了最坏情况下的时间复杂度为O(log n)。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/computer-basis/" rel="tag"><i class="fa fa-tag"></i> computer basis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/01/01/Computer_Network_Note/" rel="prev" title="Computer Network Notes">
                  <i class="fa fa-angle-left"></i> Computer Network Notes
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/01/01/Database_Note/" rel="next" title="Database Notes">
                  Database Notes <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Flynn Fu</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/MSZ-006V" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
