<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInLeft","post_block":"fadeInDown","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInLeft"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++ 11&#x2F;14&#x2F;17&#x2F;20 笔记教程链接 https:&#x2F;&#x2F;changkun.de&#x2F;modern-cpp&#x2F;zh-cn&#x2F;00-preface&#x2F;C++ 新特性总结 指针空值: 现在可以使用nullptr赋值给一个空指针，nullptr只可以被隐式转换为指针类型  123int *p &#x3D; nullptr; &#x2F;&#x2F;合法int n1 &#x3D; (int)nullptr; &#x2F;&#x2F;不合法i">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Notes">
<meta property="og:url" content="http://example.com/2024/12/30/cpp_note/index.html">
<meta property="og:site_name" content="MSZ006&#39;s Cockpit">
<meta property="og:description" content="C++ 11&#x2F;14&#x2F;17&#x2F;20 笔记教程链接 https:&#x2F;&#x2F;changkun.de&#x2F;modern-cpp&#x2F;zh-cn&#x2F;00-preface&#x2F;C++ 新特性总结 指针空值: 现在可以使用nullptr赋值给一个空指针，nullptr只可以被隐式转换为指针类型  123int *p &#x3D; nullptr; &#x2F;&#x2F;合法int n1 &#x3D; (int)nullptr; &#x2F;&#x2F;不合法i">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/image/regex1.png">
<meta property="og:image" content="http://example.com/image/regex2.png">
<meta property="og:image" content="http://example.com/image/debug_output1.png">
<meta property="og:image" content="http://example.com/image/cppn1.png">
<meta property="article:published_time" content="2024-12-31T02:00:00.000Z">
<meta property="article:modified_time" content="2025-01-02T04:36:22.183Z">
<meta property="article:author" content="Flynn Fu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/regex1.png">


<link rel="canonical" href="http://example.com/2024/12/30/cpp_note/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2024/12/30/cpp_note/","path":"2024/12/30/cpp_note/","title":"C++ Notes"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Notes | MSZ006's Cockpit</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MSZ006's Cockpit</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">MSZ006's Blogs</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About me</a></li><li class="menu-item menu-item-projects"><a href="/categories/Projects/" rel="section"><i class="fa fa-code fa-fw"></i>Projects</a></li><li class="menu-item menu-item-blogs"><a href="/categories/Blogs/" rel="section"><i class="fa fa-blog fa-fw"></i>Blogs</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11-14-17-20-%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">C++ 11&#x2F;14&#x2F;17&#x2F;20 笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%99%E7%A8%8B%E9%93%BE%E6%8E%A5-https-changkun-de-modern-cpp-zh-cn-00-preface"><span class="nav-number">2.</span> <span class="nav-text">教程链接 https:&#x2F;&#x2F;changkun.de&#x2F;modern-cpp&#x2F;zh-cn&#x2F;00-preface&#x2F;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.</span> <span class="nav-text">C++ 新特性总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">泛型lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3"><span class="nav-number">2.2.</span> <span class="nav-text">面向对象相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">线性容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">无序容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84"><span class="nav-number">2.3.3.</span> <span class="nav-text">元组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">2.5.</span> <span class="nav-text">并行与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.6.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.7.</span> <span class="nav-text">c++基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">2.8.</span> <span class="nav-text">STL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">基本语法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Flynn Fu"
      src="/images/avatar_msz006.jpg">
  <p class="site-author-name" itemprop="name">Flynn Fu</p>
  <div class="site-description" itemprop="description">No because they are easy, but because they are hard</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/MSZ-006V" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MSZ-006V" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/ymrenfu@gmail.com" title="E-Mail → ymrenfu@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/yinmingren-fu-msz006/" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;yinmingren-fu-msz006&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
      <span class="links-of-author-item">
        <a href="/files/Resume.pdf" title="Resume → files&#x2F;Resume.pdf" rel="noopener me"><i class="fa fa-file fa-fw"></i>Resume</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/30/cpp_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_msz006.jpg">
      <meta itemprop="name" content="Flynn Fu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MSZ006's Cockpit">
      <meta itemprop="description" content="No because they are easy, but because they are hard">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ Notes | MSZ006's Cockpit">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Notes
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-30 18:00:00" itemprop="dateCreated datePublished" datetime="2024-12-30T18:00:00-08:00">2024-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-01-01 20:36:22" itemprop="dateModified" datetime="2025-01-01T20:36:22-08:00">2025-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-Language-Notes/" itemprop="url" rel="index"><span itemprop="name">Programming Language Notes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="C-11-14-17-20-笔记"><a href="#C-11-14-17-20-笔记" class="headerlink" title="C++ 11&#x2F;14&#x2F;17&#x2F;20 笔记"></a>C++ 11&#x2F;14&#x2F;17&#x2F;20 笔记</h1><h1 id="教程链接-https-changkun-de-modern-cpp-zh-cn-00-preface"><a href="#教程链接-https-changkun-de-modern-cpp-zh-cn-00-preface" class="headerlink" title="教程链接 https://changkun.de/modern-cpp/zh-cn/00-preface/"></a>教程链接<br> <a target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/00-preface/">https://changkun.de/modern-cpp/zh-cn/00-preface/</a></h1><h2 id="C-新特性总结"><a href="#C-新特性总结" class="headerlink" title="C++ 新特性总结"></a>C++ 新特性总结</h2><ol>
<li><p>指针空值: 现在可以使用nullptr赋值给一个空指针，nullptr只可以被隐式转换为指针类型</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> n1 = (<span class="type">int</span>)<span class="literal">nullptr</span>; <span class="comment">//不合法</span></span><br><span class="line"><span class="type">int</span> n2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&gt;(<span class="literal">nullptr</span>); <span class="comment">//不合法</span></span><br></pre></td></tr></table></figure></li>
<li><p>nullptr_t 和 nullptr<br>nullptr是一个指针空值类型的常量，而nullptr_t是一个指针空值类型，是一个关键字，一个类型</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="type">nullptr_t</span> NullPtr;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>constexpr: 使用这个标志来修饰表达式，函数，可以告诉编译器这个函数最后会输出一个固定的数，从而让编译器在编译的时候就进行某些替换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">return_const_value</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> [<span class="built_in">return_const_value</span>()]; <span class="comment">//现在是合法的，因为constexpr关键字会把函数名替换为1</span></span><br><span class="line"><span class="comment">// constexpr也可以用在if语句里面</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"> <span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123; <span class="comment">//constexpr可以用在if语句中</span></span><br><span class="line">         <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> t + <span class="number">0.1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>POD类型(Plain Old Data)，是一种特殊类型的结构体或类。POD类型具有以下特征：</p>
<ol>
<li>所有非静态成员都是public的：POD类型的成员变量都是公开的，可以被外部访问。</li>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数：POD类型不能包含任何用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。它们必须使用默认的构造函数、析构函数和复制&#x2F;移动操作。</li>
<li>没有用户自定义的拷贝赋值运算符和移动赋值运算符：POD类型不应该包含自定义的拷贝赋值运算符和移动赋值运算符。它们应该使用默认的复制&#x2F;移动操作。</li>
<li>没有虚函数：POD类型不能包含任何虚函数，因为虚函数会引入虚函数表指针，破坏了POD的简单性和内存布局的确定性。<br><br><br>POD类型通常用于需要直接内存布局控制和与C语言交互的情况，比如与底层硬件交互或进行内存操作时。在C++11之后，POD类型的概念被扩展为标准布局类型（Standard Layout Types），并引入了更加灵活的<strong>POD类型</strong>和<strong>标准布局类型</strong>的概念。<br><br>总之，POD类型的设计目的是为了保证其简单性和内存布局的确定性，以便在需要时直接操作内存，提高程序的效率和性能。</li>
</ol>
</li>
<li><p>&#x3D;default , &#x3D;delete</p>
<ol>
<li>明确默认行为： 在某些情况下，即使类的特殊成员函数可以被默认生成，也可以使用&#x3D; default语法来显式地指示默认行为。这样做可以让代码更加清晰明了，减少歧义。</li>
<li>禁用默认实现： 在某些情况下，希望禁止编译器生成默认实现，可以使用&#x3D; default来声明这些特殊成员函数，然后在声明的同时标记为delete。这样可以防止意外的默认行为，提高代码的安全性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"> <span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"> ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 禁用默认的拷贝构造函数和赋值运算符</span></span><br><span class="line"> <span class="built_in">Myclass</span>(<span class="type">const</span> Myclass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> Myclass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Myclass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>左值，右值</p>
<ol>
<li><u><strong>左值 (lvalue, left value)</strong></u>，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。左值是一个有内存位置的对象  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// a是一个左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// 返回的是int&amp;引用，也是一个左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><u><strong>右值 (rvalue, right value)</strong></u>，右边的值，是指表达式结束后就不再存在的临时对象。一个表达式不是左值就是右值！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面都是右值</span></span><br><span class="line">var + <span class="number">1</span>; </span><br><span class="line"><span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对于左值和右值，左值到右值的转换可以是隐式的，但是右值不能转换为左值（除非特殊操作），右值可以显式的赋值给左值，没有隐式转换</li>
</ul>
<ol start="3">
<li><u><strong>纯右值 (prvalue, pure rvalue)</strong></u>，纯粹的右值或字面量。比如字面量：10，true；求值结果为字面量或匿名临时对象：1+2，3*5。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。<br><br><u><strong>注意</strong></u>:字面量除了字符串字面量以外，均为纯右值。字符串字面量为一个左值，类型为const char数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="title">char</span> <span class="params">(&amp;left)</span>[6] </span>= <span class="string">&quot;01234&quot;</span>; <span class="comment">// 此时，&quot;01234&quot;为一个左值</span></span><br></pre></td></tr></table></figure></li>
<li><u><strong>将亡值</strong></u>：即将被销毁、却能够被移动的值。可以直接把纯右值和将亡值统一看做右值，不影响<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = <span class="built_in">Get_Vector</span>();</span><br><span class="line"><span class="comment">// vec是一个左值，而函数Get_Vector()返回的东西就是一个右值（将亡值）</span></span><br></pre></td></tr></table></figure></li>
<li>右值引用：使用符号<code>&amp;&amp;</code>，比如int&amp;&amp; b &#x3D; 1合法，</li>
<li>左值引用：就是原来普通的引用<code>&amp;</code>，为变量取一个别名，所以左值引用不能接受一个右值（int&amp; b &#x3D; 1不合法）</li>
<li><code>std::move</code>，将左值参数无条件转换为右值</li>
<li>左值引用只能绑定左值，右值引用只能绑定右值。但是注意常量的左值引用可以绑定非常量左值、常量左值、右值（const int &amp; a &#x3D; 1;合法）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左值引用，使用T&amp;, 只能绑定左值</span></span><br><span class="line"><span class="comment">// 右值引用，使用T&amp;&amp;，只能绑定右值</span></span><br><span class="line"><span class="comment">// 常量左值，使用const T&amp;, 既可以绑定左值又可以绑定右值</span></span><br><span class="line"><span class="comment">// 已命名的右值引用，编译器会认为是个左值</span></span><br></pre></td></tr></table></figure></li>
<li>移动语义：（可以避免无意义的拷贝构造，加强性能），比如下面的代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>; <span class="comment">// 因为std::string是资源管理类型，它的移动语义会转移底层的动态内存资源，从而影响原变量</span></span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span></span><br><span class="line">    <span class="comment">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span></span><br><span class="line">    <span class="comment">// 这步操作后, str 中的值会变为空</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: &quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有资源管理类型使用移动语义后才会失效，(int, double, float这些都不会)，而像（unique_ptr, std::string, std::vector）这种就会失效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>完美转发：建议阅读<a target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/03-runtime/#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">https://changkun.de/modern-cpp/zh-cn/03-runtime/#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91</a><br>设计到<code>std::forward</code>来进行参数的转发(传递)</li>
</ol>
</li>
<li><p>auto类型推断，可以让编译器推理变量的类型</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">5</span>; <span class="comment">//int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">0.5</span>; <span class="comment">//double</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//作为迭代器进行遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    std::cout&lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在c++14后，下面的写法是可以的</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure>
<p> 还可以用来做模板编程和用来表示一些复杂的类型，简化代码</p>
</li>
<li><p>列表初始化，使用{}来进行初始化</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//列表初始化容器</span></span><br><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//推断auto类型为std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>decltype,可以返回表达式的类型，也可以返回一个变量的类型，用法如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mul</span><span class="params">(<span class="type">const</span> T1&amp; t1, <span class="type">const</span> T2&amp; t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 * t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 * t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n) n1 = <span class="number">6</span>; <span class="comment">//推导为int类型</span></span><br></pre></td></tr></table></figure></li>
<li><p>基于范围的for循环</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> element : vec)</span><br><span class="line">    std::cout&lt;&lt; element &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><p>多线程编程<br>相关库：thread，atomic<br>thread: 可以创建线程，提供多种方法，比如join(),wait()<br>atomic: 提供原子操作，保证对共享变量的原子访问，避免竞争</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">    atomic_llong num&#123;<span class="number">0</span>&#125;; <span class="comment">//使用atomic创建一个变量num，在t1和t2中都可以访问，而且不会出现竞争访问的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">thread <span class="title">t1</span> <span class="params">(func, <span class="number">0</span>)</span></span>; <span class="comment">//func为一个函数</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span> <span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"><span class="number">8.</span>  引用计数  </span><br><span class="line">    - **引用计数**这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存</span><br><span class="line"><span class="number">9.</span> RAII</span><br><span class="line">    -  **<span class="built_in">RAII</span> (Resource Acquisition Is Initialization) 资源获取**（初始化技术）：对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间</span><br><span class="line">    - 是一种依赖对象生命周期管理资源的技术</span><br><span class="line">        - 资源获取即初始化（RAII）：在对象构造时获取资源，在对象析构时释放资源</span><br><span class="line">        - 核心原则：通过构造函数和析构函数来自动管理资源的申请和释放</span><br><span class="line">        - 常见资源：动态内存（<span class="keyword">new</span>/<span class="keyword">delete</span>），文件句柄，线程锁，网络连接（socket），数据库连接</span><br><span class="line">    - C+<span class="number">+11</span>对RAII的支持：</span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="comment">// 智能指针</span></span><br><span class="line">    std::unique_ptr; std::shared_ptr; std::weak_ptr</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程锁</span></span><br><span class="line">    std::lock_guard; std::unique_lock</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件句柄，就是用来读取文件的</span></span><br><span class="line">    std::fstream</span><br></pre></td></tr></table></figure></li>
<li><p>智能指针<br>目的：防止内存泄露，设置的自动回收机制</p>
<ol>
<li>unique_ptr: 不允许多个unique_ptr对象指向同一块内存，拥有内存的管理权。没有拷贝构造函数，只有移动构造函数。可以使用std::make_unique函数方便的创建unique_ptr对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 创建，c++14引入</span></span><br><span class="line"><span class="comment">// make_unique()方法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); </span><br><span class="line">&#125; <span class="comment">// 底层还是使用的new方法</span></span><br><span class="line"><span class="comment">// 可以使用std::move()赋值给另外一个unique_ptr，原来的被销毁</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(std::move(p))</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>share_ptr: 通过计数的方式，多个share_ptr可以共同管理同一块内存，当计数器为0，指针所指向的内存会被释放。可以使用std::make_shared函数方便的创建shared_ptr对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 像正常指针一样访问指向的内存中存放的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 计数+1</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 计数+1</span></span><br><span class="line"><span class="type">int</span> *p = pointer.<span class="built_in">get</span>(); <span class="comment">// 获取原始指针，这样不会增加计数</span></span><br><span class="line">std::cout &lt;&lt; pointer.<span class="built_in">use_count</span>(); <span class="comment">// 输出计数器的值</span></span><br><span class="line">pointer<span class="number">3.</span><span class="built_in">reset</span>(); <span class="comment">// 来减少一个引用计数</span></span><br></pre></td></tr></table></figure></li>
<li>weak_ptr: 用来辅助share_ptr，是shared_ptr的弱引用，不会增加计数。可以使用lock()方法来将一个weak_ptr变为shared_ptr，expired()方法在资源未被释放时候，返回false，否则true</li>
</ol>
</li>
<li><p>lambda表达式<br>基本语法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获列表分为以下几种：<br></p>
<ol>
<li>值捕获，写法为[value1]。值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>; <span class="comment">//value = 100</span></span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>(); <span class="comment">//stored_value = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>引用捕获，写法为[&amp;value]。保存的是引用，值会发生变化</li>
<li>隐式捕获，<a href="%E5%BC%95%E7%94%A8%E6%8D%95%E8%8E%B7">&amp;</a>，<a href="%E5%80%BC%E6%8D%95%E8%8E%B7">&#x3D;</a></li>
<li>表达式捕获，实例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">//important原本为一个独占指针，是不会被捕获列表捕获到的，但是使用std::move()方法将其转换为右值后，就可以被捕获到了。输出为9</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="泛型lambda表达式"><a href="#泛型lambda表达式" class="headerlink" title="泛型lambda表达式"></a>泛型lambda表达式</h3><p>从c++14开始，下面的写法是可以通过编译的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y;&#125;;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3.5</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式在排序的用法</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 从大到小排序</span></span><br><span class="line">&#125;);</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nums;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]; <span class="comment">// 按照第二个元素，从大到小排序</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>结构化绑定，可以提供多返回值的功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y, z] = <span class="built_in">func</span>();</span><br><span class="line">        <span class="comment">// x=1, y=2.5, z=&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12.</span> 变长参数模版</span><br><span class="line">    ```cpp</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">test</span>;</span><br></pre></td></tr></table></figure>
<p>这个test类可以接受不限制个数的typename作为模板的形式参数，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::string&gt; <span class="comment">//合法的</span></span><br><span class="line"><span class="comment">//如果要对传入的参数进行解包的话，可以使用如下的代码，使用lambda表达式和初始化列表的方法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>noexcept</strong>：在c++11中，将异常的声明简化为：函数可能抛出异常，函数不能抛出任何异常。<br>使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 不可能抛出异常</span></span><br></pre></td></tr></table></figure></li>
<li><p>原始字符字面量：可以在一个字符串前方使用 <code>R</code> 来修饰字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">R&quot;(C:\File\Project)&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>内存对齐：C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。 <code>alignof</code> 关键字能够获得一个与平台相关的 <code>std::size_t</code> 类型的值，用于查询该平台的对齐方式，<code>alignas</code> 来重新修饰某个结构的对齐方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="type">char</span>      a;</span><br><span class="line"><span class="type">int</span>       b;</span><br><span class="line"><span class="type">double</span>    c;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(std::<span class="type">max_align_t</span>) AlignasStorage &#123;</span><br><span class="line">    <span class="type">char</span>      a;</span><br><span class="line">    <span class="type">int</span>       b;</span><br><span class="line">    <span class="type">double</span>    c;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(Storage) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(AlignasStorage) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>C++类型转换</p>
<ul>
<li>static_cast<datatype>(data): 如int转double，const转非const，void* 转 int*</li>
<li>dynamic_cast<datatype>(data): 在运行时进行基类与派生类的转换，比如将基类指针转换为派生类指针</li>
<li>const_cast(data): 将const&#x2F;volatile转换为非const&#x2F;volatile类型</li>
<li>reinterpret_cast(data): 第一个的一种补充，慎重使用</li>
</ul>
</li>
<li><p>函数签名（signature）</p>
<ul>
<li>函数签名是函数声明的一部分，用于唯一标识一个函数。它包括函数的名称和参数的类型列表，但不包括返回值类型</li>
<li>由 函数名称 + 参数类型列表（包括参数的数量、顺序、类型）组成。函数签名不包括参数的名字和返回值类型</li>
<li>函数重载是通过函数签名实现的，同时也可以唯一标识一个函数</li>
<li>和函数定义（Definition）和函数声明（Declaration）不同<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;   <span class="comment">// 签名是 func(int, double)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>;    <span class="comment">// 签名仍是 func(int, double)，和上面的冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;             <span class="comment">// 签名是 func(int)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>;          <span class="comment">// 签名是 func(double)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;                  <span class="comment">// 签名是 func()</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>std::function&lt;&gt;</strong></p>
<ul>
<li>通用、多态的函数包装器。可以存储、复制、调用任何符合特定函数签名的可调用对象（例如普通函数、lambda表达式、函数指针、成员函数指针等）</li>
<li>在使用的时候，注意要检查是否为空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法形式，signature是函数签名，但是不包含函数名字，因为std::function是类型擦除（type erasure）的实现。不关心存储的具体可调用对象的类型，只关心对象的函数签名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Signature&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>;</span><br><span class="line"><span class="comment">// 签名只包括返回类型和参数列表</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为函数参数，调用的时候，传入一个签名为void(int)的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(func)&#123; <span class="comment">// 注意要检查检查是否为空</span></span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVal</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; std::cout &lt;&lt; val &lt;&lt; std::endl; &#125; <span class="comment">// 签名为void(int)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以实现回调函数，动态行为（比如在设计模式中的策略模式，可以看成在运行的时候，动态设置不同的执行策略，通过设置不同的std::function&lt;&gt;）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以存储lambda表达式</span></span><br><span class="line">std::function&lt;<span class="type">void</span>()&gt; func = []()&#123;std::cout &lt;&lt; <span class="string">&quot;Lambda stored in std::function!&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合std::bind或std::function使用成员函数时，需要绑定对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; std::cout &lt;&lt; val &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Number obj1; <span class="comment">// 必须要绑定对象</span></span><br><span class="line">    <span class="comment">// std::placeholders::_1这个是一个占位符，用于在使用std::bind时指示某个位置的参数将由调用时传入的实际参数替代。有多个参数占位符，可以使用 _2、_3 等</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func = std::<span class="built_in">bind</span>(&amp;Number::printNum, &amp;obj1, std::placeholders::_1); </span><br><span class="line">    <span class="built_in">func</span>(<span class="number">42</span>); <span class="comment">// 输出就是42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><ol>
<li>委托构造函数，可以在同一个类的某个构造函数中调用另一个构造函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">        <span class="type">int</span> value1;</span><br><span class="line">        <span class="type">int</span> value2;</span><br><span class="line">        <span class="built_in">test</span>()&#123; value1 = <span class="number">1</span>;&#125;</span><br><span class="line">        <span class="built_in">test</span>(<span class="type">int</span> value): <span class="built_in">test</span>() &#123; <span class="comment">//可以调用test类的默认构造函数了</span></span><br><span class="line">            value2 = value;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="number">2.</span> 显式虚函数重载</span><br><span class="line">   <span class="number">1.</span> <span class="keyword">override</span>，在重载虚函数的时候使用，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译</span><br><span class="line">   ```cpp</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>final，在进行类继承的时候引入，防止被继续继承并终止虚函数继续重载 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass1</span> <span class="keyword">final</span>: Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass2</span> : SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass3</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>强类型枚举<br>使用enum class的语法进行声明，实现了类型安全，而且不能被隐式转换为整数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">new_enum</span> : <span class="type">int</span> &#123;</span><br><span class="line"> value1, value2, value3 = <span class="number">100</span>, value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来进行输出，比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">     <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">         std::ostream&gt;::type&amp; stream, <span class="type">const</span> T&amp; e)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这样，下面的代码段是合法的</span></span><br><span class="line"> std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="线性容器"><a href="#线性容器" class="headerlink" title="线性容器"></a>线性容器</h3><ol>
<li><code>std::array</code><br>与std::vector的不同：vector是自动扩容的，array的大小是固定的。当vector中删除一些元素的时候，多余的内存并不会释放<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt;arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line"> <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;); <span class="comment">// 可以使用标准库中的一些容器算法，比如std::sort</span></span><br></pre></td></tr></table></figure></li>
<li><code>std::forward_list</code><br><br>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似<br><br>与std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</li>
</ol>
<h3 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h3><ul>
<li>有序容器：<code>std::map / std::set</code>，内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</li>
<li>无序容器：<code>std::unordered_map / std::unordered_multimap , std::unordered_set / std::unordered_multiset</code><br>无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>， 在不关心容器内部元素顺序时，能够获得显著的性能提升。用法和原有的类似</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>三个核心函数：</p>
<ul>
<li>std::make_tuple: 构造元组</li>
<li>std::get: 获得元组某个位置的值</li>
<li>std::tie: 元组拆包</li>
<li>std::tuple_cat: 元组合并</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式描述了一种字符串匹配的模式。<br><br>参考<a target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/06-regex/">https://changkun.de/modern-cpp/zh-cn/06-regex/</a><br><br>一般使用正则表达式主要是实现下面三个需求：</p>
<ul>
<li>检查一个串是否包含某种形式的子串；</li>
<li>将匹配的子串替换；</li>
<li>从某个串中取出符合条件的子串。</li>
<li><img src="/image/regex1.png" alt="alt 属性文本"></li>
<li><img src="/image/regex2.png" alt="alt 属性文本"></li>
<li>相关方法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="function">std::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line">std::string fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames)&#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">regex_match</span>(fname, txt_regex) &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">// std::regex_match将会输出 0 或 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//example2</span></span><br><span class="line"><span class="function">std::regex <span class="title">base_regex</span><span class="params">(<span class="string">&quot;([a-z]+)\\.txt&quot;</span>)</span></span>;</span><br><span class="line">std::smatch base_match;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(fname, base_match, base_regex)) &#123;</span><br><span class="line">        <span class="comment">// std::smatch 的第一个元素匹配整个字符串</span></span><br><span class="line">        <span class="comment">// std::smatch 的第二个元素匹配了第一个括号表达式</span></span><br><span class="line">        <span class="keyword">if</span> (base_match.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            std::string base = base_match[<span class="number">1</span>].<span class="built_in">str</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="number">0</span>].<span class="built_in">str</span>();</span><br><span class="line">            std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>相关库：<code>std::thread, #include&lt;thread&gt;, #include&lt;mutex&gt;, std::&lt;mutex&gt;</code></p>
<ul>
<li>互斥量与临界区<br><strong>std::mutex</strong>是基本的mutex类，可以通过lock()对对象进行上锁，unlock()进行解锁。<br>可以使用c++提供的RAII语法的模板类std::lock_guard。这个方法可以保证在调用lock_guard的时候就自动加锁，同时当离开作用域的时候自动释放，避免手动上锁解锁<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> std::mutex mutex;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 已经自动加锁</span></span><br><span class="line">  <span class="comment">// 执行竞争操作</span></span><br><span class="line">  <span class="comment">// 离开作用域的时候mutex会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">  <span class="comment">// 使用lock_guard()方法保证了在离开作用域的时候自动使用unlock()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>std::unique_lock</strong>: 更加灵活，以独占所有权（没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权） 的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。<br>std::lock_guard 不能显式的调用 lock 和 unlock， 而 std::unique_lock 可以在声明后的任意位置调用（当使用std::defer_lock参数）， 可以缩小锁的作用范围，提供更高的并发度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> std::mutex mutex;</span><br><span class="line">  <span class="comment">// 如果没有加std::defer_lock, 就会自动上锁，离开作用域自动解锁</span></span><br><span class="line">  <span class="comment">// 加了这个参数后，就可以任意的加锁解锁，非常自由</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex, std::defer_lock)</span></span>;</span><br><span class="line">  lock.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="comment">// 执行竞争操作</span></span><br><span class="line">  lock.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="comment">// 此时可以抢夺v的竞争变量的使用权</span></span><br><span class="line">  lock.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="comment">// 执行竞争操作</span></span><br><span class="line">  <span class="comment">// 离开作用域的时候mutex会被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>std::future</strong>：期物，可以作为一种线程同步的手段，即屏障（barrier），可以获取异步任务的结果<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::packaged_task 可以封装任何可以调用的目标</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">123</span>;&#125;)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 获得了task的期物</span></span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">result.<span class="built_in">wait</span>(); <span class="comment">//在这里进行阻塞，一直到task任务完成才继续进行</span></span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl; <span class="comment">// 使用get()方法获取结果</span></span><br></pre></td></tr></table></figure></li>
<li><strong>std::condition_variable</strong>：条件变量，可以解决死锁问题，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。该变量用于唤醒等待线程从而避免死锁。<br>相关方法：notify_one()唤醒一个线程，notify_all()通知所有线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; produced_nums;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> notified = <span class="literal">false</span>;  <span class="comment">// 通知信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">auto</span> producer = [&amp;]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">900</span>));</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is producing &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        produced_nums.<span class="built_in">push</span>(i);</span><br><span class="line">        notified = <span class="literal">true</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>(); <span class="comment">// 此处也可以使用 notify_one</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">auto</span> consumer = [&amp;]() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        <span class="keyword">while</span> (!notified) &#123;  <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">            cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="comment">// 消费者慢于生产者</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">while</span> (!produced_nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is consuming &quot;</span> &lt;&lt; produced_nums.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">            produced_nums.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        notified = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置一个生产者线程，2个消费者线程</span></span><br><span class="line"><span class="comment">// thread 2 is producer, thread 3, 4 is consumer</span></span><br></pre></td></tr></table></figure>
运行输出如下：<img src="/image/debug_output1.png" alt="alt 属性文本"><br>在生产者中我们虽然可以使用 notify_one()，但实际上并不建议在此处使用， 因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者 争夺此锁，从而更好的利用多个消费者之间的并发。<br>同时，这个example不能实现多个消费者并行分享队列中的资源</li>
<li><strong>原子操作与内存模型</strong><br><br><strong>原子操作</strong>：<strong>std::atomic</strong>，为整数或者浮点数的原子类型提供了一些操作，可以保证很强的同步条件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  a.fetch_add(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  a++; <span class="comment">// 等于fetch_add()</span></span></span></span><br><span class="line"><span class="params"><span class="function">  a += <span class="number">1</span>; <span class="comment">// 等于fetch_add()</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
  <u>不是所有类型都提供原子操作</u>，可以使用<code>std::atomic&lt;T&gt;::is_lock_free</code>来检查该类型是否提供原子操作<br><br><strong>一致性模型</strong>:<br>存在4种不同的一致性模型，要求从强到弱<br><br>线性一致性 &gt; 顺序一致性 &gt; 因果一致性 &gt; 最终一致性<br><br><strong>内存顺序</strong>: 没看懂，建议找视频看看，参考资料<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/382372072">https://zhuanlan.zhihu.com/p/382372072</a></li>
<li>explicit 关键字<ul>
<li>用于构造函数或转换运算符，以防止隐式转换或单参数构造函数引发的意外类型转换。它主要用于避免那些可能意外发生的隐式类型转换，从而使代码更加安全和可读  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确，显式调用构造函数</span></span><br><span class="line">    <span class="built_in">func</span>(obj1);       <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">// MyClass obj2 = 10; // 错误，因为构造函数是 explicit 的</span></span><br><span class="line">    <span class="comment">// func(10);          // 错误，不能隐式地转换 int 到 MyClass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>std::variant<ul>
<li>C++ 的 std::variant 是 C++17 引入的标准库特性之一，它提供了一种类型安全的方式来存储多种可能的类型。与联合体（union）类似，std::variant 可以在运行时保存不同类型的值，但相比 union 提供了更多的安全性和功能</li>
<li>std::variant 是一个类型安全的联合体，它能够在一个变量中存储多种不同的类型，但在任何给定的时刻只能存储其中一种类型。相比传统的 union，std::variant 可以通过编译期检查，防止不安全的类型操作  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;variant&gt;</span></span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; v;  <span class="comment">// v可以存储int, float 或 std::string</span></span><br><span class="line">v = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v); <span class="comment">// 通过std::get&lt;&gt;()进行访问</span></span><br><span class="line"><span class="comment">// 通过std::visit进行访问</span></span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::string&gt; v = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> visitor = [](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(arg).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line">std::<span class="built_in">visit</span>(visitor, v);  <span class="comment">// 根据当前存储的类型执行 visitor</span></span><br></pre></td></tr></table></figure></li>
<li>特点：类型安全（只能访问当前存储的类型），类型转换保护，可以通过std::get<int>和std::visit安全的访问</li>
<li>std::variant 的内存分配等同于最大类型的大小</li>
</ul>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="c-基础知识"><a href="#c-基础知识" class="headerlink" title="c++基础知识"></a>c++基础知识</h2><ol>
<li><p>c++ new和malloc的区别</p>
<ul>
<li>new返回具体类型的指针，而malloc返回void*</li>
<li>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL</li>
<li>使⽤new操作符申请内存分配时⽆须指定内存块的⼤⼩，⽽malloc则需要显式地指出所需内存的尺⼨</li>
<li>opeartor new &#x2F;operator delete可以被᯿载，⽽malloc&#x2F;free并不允许᯿载</li>
<li>new&#x2F;delete会调⽤对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。⽽malloc则不会</li>
<li>malloc与free是C++&#x2F;C语⾔的标准库函数, new&#x2F;delete是C++的运算符</li>
</ul>
</li>
<li><p>C++ delete和free的区别</p>
<ul>
<li>delete会调⽤对象的析构函数，确保资源被正确释放。free只是简单地释放内存块</li>
<li>delete可以正确释放通过new[]分配的数组。free 不了解数组的⼤⼩，不适⽤于释放通过malloc分配的数组</li>
</ul>
</li>
<li><p>const和constexpr</p>
<ul>
<li>constexpr是常量表达式，如果一个变量为constexpr，则同样是const。但⼀个const的变量或函数，并不是constexpr的</li>
</ul>
</li>
<li><p>指针常量（Constant Pointer）和常量指针（Pointer to Constant）</p>
<ul>
<li>指针常量（Constant Pointer）是指指针本身是一个常量，也就是说，这个指针一旦初始化后，只能指向初始化时的地址，不能再指向其他地址。但是，指针指向的值可以被修改</li>
<li>指针本身不可修改（即指向的地址不能变），指针指向的值可以修改（前提是值本身不是常量） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> ptr; <span class="comment">// 只可以修改指针指向对象的值</span></span><br></pre></td></tr></table></figure></li>
<li>常量指针（Pointer to Constant）是指指针指向的值是一个常量，也就是说，不能通过该指针修改指向的值，但指针本身的指向可以改变</li>
<li>指针可以指向不同的地址, 不能通过指针修改指向地址上的值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr; <span class="comment">// 只可以修改指针指向的对象</span></span><br></pre></td></tr></table></figure></li>
<li>Constant Pointer to Constant，指针的指向，指针指向的对象都不能修改 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ptr;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数指针和指针函数</p>
<ul>
<li>函数指针（Pointer to Function）：指向函数的指针，它存储的是函数的地址。通过函数指针可以调用指向的函数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*functPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">functPtr = &amp;add;</span><br></pre></td></tr></table></figure></li>
<li>指针函数（Function Returning a Pointer）：返回值为指针的函数。它是一个普通的函数，函数返回的类型是指针类型 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">funct</span><span class="params">()</span></span>&#123;<span class="type">int</span> x = <span class="number">10</span>; <span class="keyword">return</span> &amp;x;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>struct中的成员默认是public，class默认是private</p>
</li>
<li><p>c++栈和堆</p>
<ul>
<li>栈和堆都是⽤于存储程序数据的内存区域。栈是⼀种有限的内存区域，⽤于存储局部变ᰁ、函数调⽤信息等。堆是⼀种动态分配的内存区域，⽤于存储程序运⾏时动态分配的数据</li>
<li>堆变量的生命周期由开发人员定义（new&#x2F;malloc&#x2F;delete&#x2F;free）</li>
</ul>
<p> <img src="/image/cppn1.png" alt="alt text"></p>
</li>
<li><p>内存泄漏：内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使⽤的内存的情况</p>
<ul>
<li>堆内存泄漏（heap leak）：使用new&#x2F;malloc分配的内存没有通过delete&#x2F;free释放</li>
<li>系统资源泄露（Resource leak）：系统分配的资源比如bitmap, handle, socket没有用相关函数释放或者关闭，导致浪费，效能降低，运行不稳定</li>
<li>没有将基类的析构函数定义为虚函数：当基类指针指向⼦类对象时，如果基类的析构函数不是 virtual，那么⼦类的析构函数将不会被调⽤，⼦类的资源没有正确释放</li>
</ul>
</li>
</ol>
<ul>
<li>可以通过将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；使⽤智能指针防止内存泄漏</li>
</ul>
<ol start="8">
<li><p>析构函数需要设置为虚函数，保证子类对象在释放的时候可以正确调用子类的析构函数。而构造函数不需要，没有意义</p>
</li>
<li><p>内存分配方式</p>
<ul>
<li>静态存储区域分配：在程序编译的时候就已经分配好，比如全局变量，static变量</li>
<li>栈：在执⾏函数时，函数内局部变ᰁ的存储单元都可以在栈上创建，函数执⾏结束时这些存储单元⾃动被释放</li>
<li>堆：使用new&#x2F;malloc分配，delete&#x2F;free释放，生存期自定义</li>
</ul>
</li>
<li><p>面向对象特性：继承（Inheritance），封装（Encapsulation），多态（Polymorphism）</p>
<ul>
<li>对于public, private, protected继承，私有成员不能被“派⽣类”访问，基类中的公有和保护成员能被“派⽣类”访问</li>
<li>对于公有继承，只有基类中的公有成员能被“派⽣类对象”访问，保护和私有成员不能被“派⽣类对象”访问。对于私<br>有和保护继承，基类中的所有成员不能被“派⽣类对象”访问</li>
<li>多态：简单来说，就是允许将派生类指针赋值给基类指针</li>
</ul>
</li>
<li><p>override和overload</p>
<ul>
<li>override是重写，覆盖，一般是派生类覆写基类的函数，⽅数列表，返回值，所抛出的异常要与基类中的一致</li>
<li>overload是重载，一般是普通函数，有相同函数名但是不同参数列表</li>
</ul>
</li>
<li><p>C++的多态（Polymorphism）通过虚函数（Virtual Function）和虚函数表（Virtual function table）实现</p>
<ul>
<li>基类中声明虚函数，而在派生类中使用override进行覆写</li>
<li>使用基类指针指向派生类对象，调用虚函数</li>
<li>虚函数表：编译器在对象的内存布局中维护了⼀个虚函数表，其中存储了指向实际函数的指针。这个表在运⾏时⽤于动态查找调⽤的函数</li>
</ul>
</li>
<li><p>相关概念：虚函数，纯虚函数，抽象类</p>
<ul>
<li>纯虚函数是在抽象类中声明的虚函数，它没有具体的实现，只有函数的声明。派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类</li>
<li>抽象类是不能被实例化的类，它存在的主要⽬的是为了提供⼀个接⼝，供派⽣类继承和实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funct1</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funct2</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure></li>
<li>常⻅的不能声明为虚函数的有：普通函数（⾮成员函数），静态成员函数，内联成员函数，构造函数，友元函数</li>
</ul>
</li>
<li><p>深拷贝，浅拷贝</p>
<ul>
<li>深拷⻉是对对象的完全独⽴复制，包括对象内部动态分配的资源。在深拷⻉中，不仅复制对象的值，还会复制对象所指向的堆上的数据</li>
<li>浅拷⻉仅复制对象的值，⽽不涉及对象内部动态分配的资源。在浅拷⻉中，新对象和原对象共享相同的资源，⽽不是复制⼀份新的资源</li>
</ul>
</li>
<li><p>C++引用（reference）</p>
<ul>
<li>不可以重新绑定对象</li>
<li>不可能创建空引用，必须初始化</li>
<li>可以作为函数返回值，作为函数参数传递，用于类的构造函数</li>
</ul>
</li>
<li><p><strong>assert</strong></p>
<ul>
<li>是一个宏，用法为assert(expression), 包含在<cassert>库中，当expression为true的时候，程序继续执行。当expression为false的时候，程序终止执行，并且输出错误信息</li>
</ul>
</li>
<li><p>回调函数（callback function）</p>
<ul>
<li>是一种函数，通过指针或引用传递给另一个函数，后者可以在适当的时间调用这个回调函数。回调函数的主要用途是实现一种“反向控制”的机制，使得被调用的函数在某些条件满足时能够通知调用者，并且根据调用者提供的行为做出响应</li>
<li>可以判断多个条件，如<code>assert(x &gt; 0 &amp;&amp; y &gt; 0)</code></li>
<li>对性能的影响比较轻微（只在调试期间），而在软件发布版本（会禁用所有assert，所以没有任何影响）</li>
<li>允许将函数作为参数传递，并在合适的时间调用</li>
<li>可以使用函数指针，lambda表达式，类成员函数，仿函数进行调用</li>
<li>是事件驱动编程的核心概念，广泛应用于图形用户界面（GUI）编程、异步编程等领域<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数实现，同时使用std::function&lt;&gt;特性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCallback</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trigger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">            <span class="built_in">callback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Event event;</span><br><span class="line">    <span class="comment">// 设置回调函数</span></span><br><span class="line">    event.<span class="built_in">setCallback</span>([]() &#123; std::cout &lt;&lt; <span class="string">&quot;Event triggered!&quot;</span> &lt;&lt; std::endl; &#125;);</span><br><span class="line">    event.<span class="built_in">trigger</span>();  <span class="comment">// 触发事件，调用回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><ul>
<li>由6部分组成：容器（Container），算法（Algorithm），迭代器（Iterator），仿函数（Function Object），适配器（Adapter），空间配置器（Allocator）</li>
<li>container：vector, queue, list, set, map</li>
<li>algorithm: sort(), find(), copy()</li>
<li>map, set底层是基于红黑树进行实现的，而unordered_map, unordered_set底层是基于哈希表实现的</li>
<li>emplace_back()比push_back()更高效，因为它避免了创建和销毁临时对象的开销</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>数据结构相关<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在c++中，栈库为#include&lt;stack&gt;</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">// 相关方法：push(int i), pop(), top()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;vector&gt; 使用vector库</span></span><br><span class="line"><span class="comment">// 初始化长度为n，默认值为0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 初始化n*m的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 在函数中引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title">grid</span><span class="params">(n, vector&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>))</span></span></span><br><span class="line"><span class="function">nums.<span class="title">push_back</span><span class="params">()</span></span>; nums.<span class="built_in">pop_back</span>(); <span class="comment">// 从末尾压入元素 / 移除最后一个元素</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target); nums.<span class="built_in">erase</span>(it); <span class="comment">// 找到某元素然后删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;list&gt; 使用list库，是一个双向链表</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">nums.<span class="built_in">push_front</span>(<span class="number">4</span>); nums.<span class="built_in">push_back</span>(<span class="number">4</span>);<span class="comment">// 在链表头插入元素，在链表尾插入元素</span></span><br><span class="line">nums.<span class="built_in">pop_back</span>(); nums.<span class="built_in">pop_front</span>(); <span class="comment">// 删除最后一个和第一个元素</span></span><br><span class="line">nums.<span class="built_in">front</span>(); nums.<span class="built_in">back</span>(); <span class="comment">// 访问第一个和最后一个元素</span></span><br><span class="line">nums.<span class="built_in">size</span>(); <span class="comment">// 链表大小</span></span><br><span class="line">nums.<span class="built_in">empty</span>(); <span class="comment">// true为空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:nums) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 遍历list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::unordered_map 是一种关联容器，允许你存储键值对。每个键（key）是唯一的，并且与一个值（value）相关联。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// 储存一个键值对，类型都为int</span></span><br><span class="line">map.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;) <span class="comment">// or map[1]=2</span></span><br><span class="line">map.<span class="built_in">erase</span>(<span class="number">2</span>) <span class="comment">// 删除键为2的元素</span></span><br><span class="line"><span class="keyword">auto</span> it = map.<span class="built_in">find</span>(<span class="number">2</span>) <span class="comment">// 查找键为2的元素，返回迭代器</span></span><br><span class="line"><span class="keyword">if</span> (map.<span class="built_in">find</span>(<span class="number">3</span>) != map.<span class="built_in">end</span>()) <span class="comment">// 检查元素是否存在</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Key 3 exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">map.<span class="built_in">contains</span>(<span class="number">3</span>); <span class="comment">// c++20引入新的方法，检查元素是否存在，返回bool类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; pair:map)</span><br><span class="line">  std::cout &lt;&lt; pair.first &lt;&lt; pair.second; <span class="comment">// first is key, second is value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::unordered_set 是一种无序集合容器，允许你存储唯一的元素，并提供快速的插入、删除和查找操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">set.<span class="built_in">count</span>(<span class="number">2</span>) <span class="comment">// 检查set中是否存在2这个元素，因为set只能储存唯一的元素，所以只能有1个2或者0个2，返回1或0</span></span><br><span class="line">set.<span class="built_in">insert</span>(<span class="number">3</span>) <span class="comment">// 插入元素</span></span><br><span class="line">set.<span class="built_in">erase</span>(<span class="number">3</span>) <span class="comment">// 删除元素</span></span><br><span class="line"><span class="keyword">auto</span> it = set.<span class="built_in">find</span>(<span class="number">3</span>) <span class="comment">// 查找指定元素所在位置，返回迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span>&amp; elem:set)</span><br><span class="line">  std::cout &lt;&lt; elem; <span class="comment">// 遍历</span></span><br><span class="line">set.<span class="built_in">contains</span>(<span class="number">3</span>); <span class="comment">// 检查是否含有元素3，返回bool类型，比find好用简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::queue是队列，相关操作如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="type">int</span> num1 = queue.<span class="built_in">front</span>();</span><br><span class="line">queue.<span class="built_in">front</span>(); <span class="comment">// 返回队头元素，不弹出</span></span><br><span class="line">queue.<span class="built_in">pop</span>(); <span class="comment">// 先获取队头元素，然后弹出队头元素</span></span><br><span class="line">queue.<span class="built_in">empty</span>() <span class="comment">// True为空，False为不空</span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">// 从队尾插入元素1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// priority_queue 优先队列，可以用来实现最大堆和最小堆，默认是最大堆</span></span><br><span class="line"><span class="comment">// 底层是基于二叉堆实现的，插入一个新元素需要经过Bubble up操作进行调整</span></span><br><span class="line"><span class="comment">// 调整需要O(logn)时间，所以插入元素时间复杂度是O(logn)</span></span><br><span class="line"><span class="comment">// 插入元素O(logn), 访问元素top() O(1), 删除元素pop() O(logn)</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 最大堆，最大的元素在队头</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; pq_min; <span class="comment">// 最小堆，最小的元素在队头 </span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> DATATYPE* a, <span class="type">const</span> DATATYPE* b) &#123;</span><br><span class="line">          <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="comment">// 最小堆, 这里的排序逻辑是a比b大，那么a优先级就低，b优先级高，优先队列把优先级高的放在最前面，所以这是一个最小堆</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;DATATYPE, vector&lt;DATATYPE&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq; <span class="comment">// 同样是一个最小堆，但是是自定义的数据结构</span></span><br><span class="line">pq.<span class="built_in">pop</span>();pq.<span class="built_in">top</span>();pq.<span class="built_in">push</span>();</span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [&amp;](<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt;&amp; pq)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// set()，可以使用自定义的排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operate</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> in &amp;b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; nums; <span class="comment">// 一个降序排序的set</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, cmp&gt; ht; <span class="comment">// 一个降序排序的map</span></span><br><span class="line"><span class="comment">// 同时也可以用std::greate&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pair, #include&lt;utility&gt;</span></span><br><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; obj1; <span class="comment">// 默认构造一个pair</span></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 构造一个pair&lt;int, string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deque, #include&lt;deque&gt;双端队列</span></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 可以使用初始化列表构造，比如&#123;1, 2, 3&#125;, (nums.begin(), nums.end())</span></span><br><span class="line">dq[<span class="number">1</span>], dq.<span class="built_in">at</span>(<span class="number">2</span>), dq.<span class="built_in">front</span>(), dq.<span class="built_in">back</span>(); <span class="comment">// 按下标访问和访问头尾元素</span></span><br><span class="line"><span class="built_in">push_front</span>(), <span class="built_in">push_back</span>(), <span class="built_in">pop_back</span>(), <span class="built_in">pop_front</span>();</span><br><span class="line"><span class="comment">// 在头部和尾部插入或删除元素的效率为常数时间O(1)</span></span><br><span class="line"><span class="comment">// 而Vector插入/删除头部元素是O(n)，支持随机访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multiset，有序集合，可以存储重复元素</span></span><br><span class="line">std::multiset&lt;<span class="type">int</span>&gt; ms = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">insert</span>(), <span class="built_in">find</span>(), <span class="built_in">erase</span>(), <span class="built_in">count</span>(); <span class="comment">// 插入，寻找，清除指定迭代器下标，计算数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line">std::multimap&lt;<span class="type">int</span>, std::string&gt; mm = &#123;</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;dos&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">insert</span>(), <span class="built_in">find</span>(), <span class="built_in">erase</span>(), <span class="built_in">count</span>(); <span class="comment">// 插入，寻找，清除指定迭代器下标，计算数量</span></span><br><span class="line"><span class="keyword">auto</span> range = mm.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="comment">// 输出two, dos</span></span><br></pre></td></tr></table></figure></li>
<li>内存分配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> memo[c][m][n];</span><br><span class="line"><span class="built_in">memset</span>(memo, <span class="number">-1</span>, <span class="built_in">sizeof</span>(memo)); <span class="comment">// 给memo分配空间，初始化为-1</span></span><br><span class="line"><span class="type">int</span> &amp;res = memo[k][i][j]; <span class="comment">// 使用res直接引用memo中的[k][i][j]，会随着res更改而更改，减少代码，保证安全</span></span><br></pre></td></tr></table></figure></li>
<li>数据转换相关<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// atoi(), stoi(), using by #include&lt;cstring&gt;, 把字符串转换为int类型输出</span></span><br><span class="line">  <span class="comment">// atoi()不做范围检查，超出范围也进行输出</span></span><br><span class="line">  <span class="comment">// stoi()做范围检查，超出范围则runtime error</span></span><br><span class="line">- c++排序相关</span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="comment">// 对于一个vector&lt;int&gt; arr数组，可以写一个排序函数，需要#include&lt;algorithm&gt;</span></span><br><span class="line">  <span class="comment">// 当cmp返回true的时候，sort函数会认为a应该在b前面，所以当a &gt; b返回true，sort()就把a排在b前面，所以就是一个降序排序，最大的在最前面</span></span><br><span class="line">  <span class="comment">// 所以写return a &lt; b, 返回true的时候，a排b前面，b比a大，所以是一个增序</span></span><br><span class="line">  <span class="comment">// 这个排序的规则和优先队列那个排序规则不一样的</span></span><br><span class="line">  <span class="keyword">auto</span> cmp = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">  <span class="comment">// 其中cmp是排序规则，默认是升序排序，下面是降序排序</span></span><br><span class="line">  <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// </span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li>c++ string相关<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转字符串</span></span><br><span class="line">string s = std::<span class="built_in">to_string</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 对于一个vector&lt;int&gt; arr数组，可以写一个排序函数，需要#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="comment">// 其中cmp是排序规则，默认是升序排序，下面是降序排序</span></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割字符串, 方法1</span></span><br><span class="line">std::string sentence = <span class="string">&quot;Hello my name is Jane&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; words;</span><br><span class="line"><span class="type">size_t</span> start = <span class="number">0</span>, end;</span><br><span class="line"><span class="keyword">while</span> ((end = sentence.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, start)) != std::string::npos) &#123;</span><br><span class="line">  words.<span class="built_in">push_back</span>(sentence.<span class="built_in">substr</span>(start, end - start));</span><br><span class="line">  start = end + <span class="number">1</span>; <span class="comment">// 移动到下一个单词的起始位置</span></span><br><span class="line">&#125;</span><br><span class="line">words.<span class="built_in">push_back</span>(sentence.<span class="built_in">substr</span>(start)); <span class="comment">// 最后一个单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割字符串, 方法2，#include&lt;sstream&gt;</span></span><br><span class="line">std::string sentence = <span class="string">&quot;Hello my name is Jane&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; words;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(sentence)</span></span>;</span><br><span class="line">string temp;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(iss, temp, <span class="string">&#x27; &#x27;</span>))&#123;</span><br><span class="line">  words.<span class="built_in">push_back</span>(temp); <span class="comment">// 按照&#x27; &#x27;对sentence进行分割，每次找到一个&#x27; &#x27;，就存入temp中，然后再把temp压入vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用空格连接字符串</span></span><br><span class="line">vector&lt;string&gt; word_list = &#123;<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;bat&quot;</span>,<span class="string">&quot;rat&quot;</span>&#125;;</span><br><span class="line">string result = <span class="built_in">accumulate</span>(word_list.<span class="built_in">begin</span>() + <span class="number">1</span>, word_list.<span class="built_in">end</span>(), word_list[<span class="number">0</span>], [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="string">&quot; &quot;</span> + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// result结果，使用空格将字符串都连接起来了，结果就是cat bat rat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string, push_back(), pop_back()</span></span><br><span class="line">string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">str.<span class="built_in">pop_back</span>(); <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda expression</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TryCall</span><span class="params">(<span class="type">int</span> val, std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; callback)</span></span>&#123; <span class="comment">// 对于接受回调函数为参数的这个函数</span></span><br><span class="line">      val += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">callback</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ClassCallBack</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">      std::cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">TryCall</span>(<span class="number">10</span>, [](<span class="type">int</span> val)&#123; <span class="comment">// 使用lambda表达式进行调用</span></span><br><span class="line">      std::cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 或者使用成员函数进行调用</span></span><br><span class="line">  Myclass obj;</span><br><span class="line">  <span class="built_in">TryCall</span>(<span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;Myclass::ClassCallBack, &amp;obj, std::placeholders::_1));</span><br><span class="line">  <span class="comment">// obj是一个对象，实际上会发生obj.ClassCallBack(), 而placeholders::_1是一个占位符，在调用时，_1会被传入的第一个参数替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>cpp相关实用方法  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A - Z: 65 ~ 90</span></span><br><span class="line"><span class="comment">// a - z: 97 ~ 122</span></span><br><span class="line"><span class="comment">// uppercase + 32 = lowercase</span></span><br><span class="line"><span class="comment">// 数字的范围是48 ~ 57（0 ~ 9）</span></span><br><span class="line"><span class="comment">// 取一个最大的数</span></span><br><span class="line"><span class="type">int</span> max_value = INT_MAX;</span><br><span class="line"><span class="comment">// 对于这种数据结构，通过键查找对于的数组的时候，一定要使用引用</span></span><br><span class="line"><span class="comment">// 这样就可以取到原来map中保存的vector地址。不使用引用会把原来的数据全部复制到一个新地址，就慢了</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; ht;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;&amp; arr = ht[key]; <span class="comment">// 一定要这么写！快很多！</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_v = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 计算一个数组中最大的数</span></span><br><span class="line"><span class="type">int</span> min_v = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 计算一个数组中最大的数</span></span><br><span class="line"><span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 计算一个数组的和</span></span><br><span class="line"><span class="built_in">reverse</span>(nuns.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()) <span class="comment">// 反转一个数组</span></span><br><span class="line">string str;</span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// substr(pos, len) 从pos开始，输出长度为len的子串</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(a, b); <span class="comment">// 交换a, b的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁的控制域限定，锁一般是在竞争区域中使用，比如</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">static</span>  std::mutex mutex;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 此时，进入这个大括号就会创建一个锁</span></span><br><span class="line">    <span class="comment">// 这个大括号内部就是竞争区域，当离开这个区域的时候，就会自动解锁了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++对于某个数num，向上取整的方法</span></span><br><span class="line"><span class="type">int</span> res = (num - <span class="number">1</span>) / divisor + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 向下取整就直接用int类型就行了，会自动向下取整的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取出哈希表中所有元素的方法</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;ht;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">kv</span>(ht.<span class="built_in">begin</span>(), ht.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取随机数</span></span><br><span class="line"><span class="comment">// 可以使用std::srand(std::time(0))设置随机种子，得到相同随机序列</span></span><br><span class="line"><span class="type">int</span> random_range = std::<span class="built_in">rand</span>()%<span class="number">100</span>; <span class="comment">// 生成0~99中的随机数</span></span><br><span class="line"><span class="type">int</span> random_value = std::<span class="built_in">rand</span>(); <span class="comment">// 生成随机数</span></span><br><span class="line"><span class="comment">// 可使用&lt;random&gt;库，std::mt19937引擎生成随机数</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">gen</span><span class="params">(std::random_device&#123;&#125;())</span></span>; <span class="comment">// 随机数生成器</span></span><br><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dis</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>; <span class="comment">// 0 到 1 的浮点数均匀分布</span></span><br><span class="line"><span class="type">double</span> value = <span class="built_in">dis</span>(gen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学相关</span></span><br><span class="line"><span class="built_in">gcd</span>(x, y) <span class="comment">// Greatest Common Divisor, GCD, 返回x和y的最大公因数</span></span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/12/29/About/" rel="prev" title="Introduction">
                  <i class="fa fa-angle-left"></i> Introduction
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/12/30/leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="next" title="Leetcode Notes">
                  Leetcode Notes <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Flynn Fu</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/MSZ-006V" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
